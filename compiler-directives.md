
# [Zax Programming Language](index.md)

## Compiler Directives

### Official and extended directives

All officially supported directives must be understood to compile and never start with an `x-` prefix. Custom compiler directives and custom directive arguments are prefixed with `x-` in the directive name. Custom directives and custom directive arguments are ignored if they are not supported.

````zax
// example official directives
variable final [[inline]] : ()() = {
    // ...
}
[[source="example.zax"]]


// examples of unofficial custom directives...

func final [[x-bytecode=lacrosse]] : ()()

[[x-bogus="party on dudes!"]]

[[source="example2.zax", x-]]
````


### The `source` directive

A `source` compiler directive `[[source="<path/file.zax>", required=<yes|no|warn>, generated=<yes|no>]]` instructs a compiler to pause compiling the current file and continue compiling tokens from a referenced file until that file is completely parsed then resume compiling the current file. A `source` directive always locates files relative to the current file. If a path is not found, then the parent of the current path is attempted (recursively to the root of a module) until a `source` is located or the file is not found (whereupon a compiler will issue an error). Paths are always separated with unix forward slashes ('/') regardless of the platform. File names are recommended to be always lowercase and words should be separated with a dash (`-`) sign.

An optional argument named `required` is available. If the value is `yes` then a file must be found (default behavior) or a `source-not-found` error will occur. If `required` is `no` then a compiler will ignore this file being absent. If `required` is `warn` then a compiler will issue the `source-not-found` warning. A file extension of `zax` is the recommended default extension.

An optional argument named `generated` is available. If the value is `yes`, then a source file needs to be generated by one of a compiler's `execute` directives. Prior to attempting to load and and parse a file, the generated file date is checked and if the compile date is newer than the generated file date then a compiler will issue a `generated-file-not-touched` warning. Generated files must (at minimal) be "touched" by a generator. A default value of `no` is assumed (and redundant to specify).

A [wildcard character](https://en.wikipedia.org/wiki/Wildcard_character) pattern matching notation is allowed. Multiple matched files are imported in ascending ASCII sort order and a source will never import itself when using a wild card.

````zax
/*
file.zax
*/

[[source="options.zax", required=warn]]
[[source="graphics/*.zax"]]
[[source="sub-path/sub-file.zax"]]
[[source="generated/keyboardMapping.zax", generated=yes]]
````

````zax
/*
sub-path/sub-file.zax
*/

[[source="options.zax", required=no]]
````


### The `asset` directive

An `asset` compiler directive `[[asset="<path/file.ext>", required=<yes|no|warn>, rename="<new-path/new-name.ext>", generated=<yes|no>]]` instructs a compiler copy a file into an output target's asset folder. An `asset` directive always locates files relative to the current file. If a path is not found, then a parent of the current path is attempted (recursively to the root of a module) until an `asset` is located or the file is not found (where a compiler will issue an error). Paths are always separated with unix forward slashes ('/').

An optional argument named `required` is available. If the value is `yes` then a file must be found (default behavior) or an `asset-not-found` error will be issued. If `required` is `no` then a compiler will ignore this file being absent. If `required` is `warn` then a compiler will issue an `asset-not-found` warning.

An optional argument named `generated` is available. If the value is `yes`, then the asset file needs to be generated by one of the compiler's `execute` directives. Prior to attempting to copy a file, the generated file date is checked and if the compile date is newer than the generated file date then a compiler will issue a `generated-file-not-touched` warning. A default value of `no` is assumed (and redundant to specify).

The [wildcard character](https://en.wikipedia.org/wiki/Wildcard_character) pattern matching notation is allowed. Multiple matched files are imported in ascending ASCII sort order. If a wild card character is used with the rename option then the same wild card character must be present in the `rename`. All wild card characters in the rename must be present in the same order or the `wild-character-mismatch` error will be issued.

````zax
/*
file.zax
*/

[[asset="intro.wav", required=warn]]
[[asset="graphics/*.png"]]
[[asset="sub-path/example-*.pdf", rename="examples/*.pdf"]]
[[asset="palette.png", generated=yes]]
````

````zax
/*
sub-path/sub-file.zax
*/

[[source="options.zax", required=no]]
````


### The `panic` directive

#### The `panic` function

When a panic occurs, the context's panic function is called (`___.panic(...)`). Normally an error message is displayed for the programmer to understand the panic and then a program terminates due to the unexpected and unhandled condition. A default `panic` function can be replaced with an alternative function.

A panic function is called with an enumeration representing the current error code and a code location is passed containing the source location of where a panic condition was triggered.


#### The pre-panic check function

When a panic occurs in code that is always compiled in (and cannot be removed by direct compiler directive), the context's pre-panic check function is called (`___.prePanicCheck(...)`). This function accepts an enumeration representing the error where a lookup table can be searched to see if the panic is enabled for the panic code. If a panic is enabled then a context's panic function is called. If a panic is suppressed then the panic function is never called.

A pointer to the lookup table is maintained within the context object. A programmer can swap in/out the lookup table pointer to other states if a code section has different run-time only panic criteria for a given context.


#### Enabling/disabling a compiler panics

Code generation for panic conditions can be enabled or disabled by using a `[[panic=<option>, registered-<panic-name>]]` directive. If a compiler compiles-in the `panic` directive, a compiler will enable or disable the compiler panic code generation. All compilers must register their panic options and meanings into a shared authority registry. Experimental non-standard panic names must include an `x-` prefix as part of the panic name. Naming a specific panic is optional. If the compiler panic name is not specified, the directive will apply to all panic conditions.

Caution: disabling panics does not prevent the panic scenario; disabling merely removes additional compiler generated protective code that would call a panic function. Without compiling in panic detection, the code may silently fail with undefined behaviors.

The options for panic conditions are:
* `yes` - enables the panic for only to the current statement
* `no` - disables the panic for only to the current statement
* `always` - enables the panic for all statements that follow
* `never` - disables the panic for all statements that follow
* `default` - enables or disables the panic for all statements that follow according to the compiler's defaults
* `lock` - disallows any imported module from changing a panic state
* `unlock` - allows any imported module from changing a panic state

````zax
randomValue final : (output : S32)() = {
    // ...
    return output
}

value := randomValue()

[[panic=no, intrinsic-type-cast-overflow]] \
castedValue1 := value as U16

[[panic=yes, intrinsic-type-cast-overflow]] \
castedValue2 := value unsafe as U8

[[panic=always, intrinsic-type-cast-overflow]]

// ...

[[panic=never, intrinsic-type-cast-overflow]]

// ...

[[panic=default, intrinsic-type-cast-overflow]]

// ...

[[panic=never, x-strange-experimental-panic]]
````


#### Panic `push` and `pop`

The state of all panics can be pushed and popped into a compile stack using the `[[panic=push]]` and `[[panic=pop]]` compiler directives. A push operation will keep a copy of all panic states and push these panic states on the compiler stack. A `pop` operation will take the last pushed compiler panic states and apply these panic states as the current panic states.

Upon importing a module, all panic states are pushed and all panic states are popped at the end of an `import`. This ensures that imported modules cannot affect the panic state of the importing module.

````zax
[[panic=push]]

[[panic=never, intrinsic-type-cast-overflow]]

// ... code with the panic checks disabled

[[panic=pop]]
````


#### Panic registry and meanings

The following are registered panic scenarios, default states, and their meaning:
* `out-of-memory` (always)
    * memory was requested to be allocated but insufficient memory exists to fill the request
* `intrinsic-type-cast-overflow` (always)
    * an intrinsic type may overflow during the `as` operator to a type with lower bit sizing
* `string-conversion-contains-illegal-sequence` (always)
    * a string literal conversion was found to contain an illegal character sequence during the conversion process
* `reference-from-pointer-to-nothing` (always)
    * a pointer was converted to a reference but the pointer points to nothing
* `pointer-to-nothing-accessed` (always)
    * a value (or function) was accessed but the pointer points to nothing
* `not-all-pointers-deallocated-during-allocator-cleanup`
    * memory cleanup is being performed but not all the allocated memory from the allocator was deallocated
* `impossible-switch-value` (always)
    * a `switch` statement encounter a value which can never happen (because of the `[[never]]` directive or the `[[always]]` directive)
* `impossible-if-value` (always)
    * an `if` statement encounter a value which can never happen (because of the `[[never]]` directive or the `[[always]]` directive)
* `impossible-code-flow` (always)
    * a code path was followed what was marked as impossible (because of the `[[never]]` directive or the `[[always]]` directive)
* `lazy-already-complete` (always)
    * an attempt was made to call a `lazy` function that has already returned from the function
* `value-polymorphic-function-not-found` (always)
    * a function supporting value polymorphism was called but none of the pre-condition checks succeeded


### The `deprecate` directive

A `[[deprecate=<option>, context=<context>, error, min="<x.x>", max="<x.x>"]]` directive can be used to cause API usages to be considered deprecated. Any usages found to be deprecated will issue a `deprecate-directive` warning or error. This directive is useful for allow grace periods to exist when upgrading to access older obsoleted APIs as well as an upgrade path to newer APIs while still maintaining compatibility with an older required API.

The options for a `deprecate` directive are:
* `yes` (default) - enables the deprecation for only to the current statement
* `no` - disables the deprecation for only to the current statement
* `always` - enables the deprecation for all statements that follow
* `never` - disables deprecation for all statements that follow (`context`, `error`, `min`, `max`, are disallowed)

An `error` argument is optional and if specified a warning is forced into an error without a possibility to ignore a deprecation as a mere warning.

Context for a deprecate warning:
* `import` (default) - only warn on usages from module performing the import
* `all` - any usage of this item is to be treated as deprecated
* `local` - any usage of this item in the local context is deprecated

A `min` option requires an importing module must declare an import of at least this version to use an API. A `max` option requires an importing module must not declare an import version greater than this version to use an API. A compiler will treat versions as [point release](https://en.wikipedia.org/wiki/Point_release) notations. A version can be specified using a `version` `String` declaration in an import statement. The `min` and `max` keywords are generally not used together but they can be.

Only one `always` deprecation can be active at a time. A `never` directive will disable any active `always`. Usage of `never` cannot be declared with `error`, `min`, `max` or `context` as they have no applicability and will issue an `incompatible-directive` error. Individual `yes` or `no` temporarily override any `always` deprecations directives for a current statement. Any current deprecation state will not apply to imported modules. There's no way to `push` or `pop` deprecations unlike `panic`, `warning`, or `error` directives.

````zax
[[deprecate]] \
MyOldBadlyDesignedType :: type {
    // ...
}

// usage of this type should only be performed when
// requesting this version number at minimum
[[deprecate, min="2.3"]] \
MyShinyNewType :: type {
    // ...
}

ValidType :: type {

    // all of the functions and variables below are now obsoleted and
    // cannot be used beyond version 1.1
    [[deprecate=always, error, max="1.1"]]

    mrT80sFunc : ()() = {
        // ...
    }

    markyMarkFunc : ()() = {
        // ...
    }

    eightTrack : MyOldBadlyDesignedType

    // disable the last `always` deprecation directive
    [[deprecate=never]]


    // this function is deprecated if used accessed in the local context
    [[deprecate, context=local]] \
    needsRedesignFunc : ()() = {
        // ...
    }

    // this function is always warned as being deprecated
    [[deprecate, context=all]] \
    mightNeedThisSoNotReadyToRemoveFunc : ()() = {
        // ...
    }

    newerOkayFunc : ()() = {
        // ...
    }
}
````


### The `inline` function directives

An `inline` directive ``[[inline=option]]`` can be used to signal to a compiler when to inline a `final` function directly into code or when to call a function as an explicit function call. By default a compiler will decide if inlining a function is desirable.

The following options are available for an inline directive:
* `maybe` (default) - a compiler decides if it is best to `inline` a function or not
* `always` - a compiler is forced to `inline` a function but all variables declared are not visible to a caller's scope
* `descope` - a compiler is forced to `inline` a function and all variables declared are visible to a caller's scope
* `never` - a compiler may never `inline` this function

````zax
// prefer the function to inline
func1 final [[inline]] : ()() = {
    // ...
}

// let the compiler decide if inlining is preferred or not
func2 final [[inline=maybe]] : ()() = {
    // ...
}

// only allow the function to be created inline
func2 final [[inline=always]] : ()() = {
    // ...
    myValue : Integer
    // ...
}

// only allow the function to be created inline
func3 final [[inline=descope]] : ()() = {
    // ...
    myValue : Integer
    // ...
}

// never allow the function to be inlined
func4 final [[inline=never]] : ()() = {
    // ...
}

func1()
func2()

[[descope]] \
func3() // calling a function with an `[[inline=descope]]` requires a
        // declaration of `[[descope]]` on a function or a warning
        // `descope-directive-required` will be issued
func4()

// OKAY: a definition for `myValue` comes from the `[[inline=descope]]`
myValue *= 3

// ...
````


### The `descope` directive

A `[[descope]]` directive treats an inner scope as belonging to a scope of an outer scope. As such, no destructors will trigger at the end of scope and all variables declared as part of a scope are treated with the same visibility as an outer scope. Variables declared within a `descope` are treated as having been declared as part of an outer scope thus non-polymorphic variables with the same name will cause a `duplicate-symbol` error rather than shadowing an outer variable.

Example when used with a compile-time `if` statement:

````zax
[[descope]] if true {
    myValue : U32 = 5
    // ...
} else {
    myValue : U16 = 10
    // ...
}

myValue *= 2
````

Example when used with a normal scope:

````zax
[[descope]] scope my_scope {
    myValue1 : Integer = 6
    myValue2 : Integer = 7
    // ...
}

myValue1 *= 2 + myValue2
````

Example of possible flow control error condition when used with a normal scope:

````zax
[[descope]] scope my_scope {
    myValue1 : Integer = 6

    if true
        break   // ERROR: will issue `scope-flow-control-skips-declaration`
                // as `myValue2` declaration would be skipped

    myValue2 : Integer = 7
    // ...
}

myValue1 *= 2 + myValue2
````


### The `compile` directive

A `compile` directive can be used on input arguments to indicate a value must be pre-evaluated at compile time or an error will be issued. Any input argument declared with a `compile` directive must also be declared as either `constant` or `immutable`. Any variadic types are treated as `constant` or `immutable`.

````zax
func print : ()([[compile]] ...) = {
    // ... all arguments must resolve at compile time ...
}

func final : ()(input [[compile]] : Integer constant) = {
}

random1 final [[execute=dual]] : ()() = {
    // ...
}

random2 final [[execute=runtime]] : ()() = {
    // ...
}

// capture a runtime only value
value := random2()

func(5)            // OKAY: the value is constant
func(random1())    // OKAY: the function is allowed to resolves as a compile
                   // time constant

func(random2())    // ERROR: the function cannot resolve at compile time
func(value)        // ERROR: the value is run-time only and not constant

print(5, "hello", random1())   // OKAY: the value is compile time constant
print(random2(), value)        // ERROR: runtime only values cannot become
                               // compile time constants
````


### The `compiles` directive

A `compiles` directive `[[compiles, error]]` evaluates a code block that converts into a compile-time constant of `true` or `false`. A code block that follows a `compiles` directive is never executed and declarations and any definitions within a code block do not become visible symbols and a `compiles` code block will not resolve into code instructions.

If `error` is specified then a failure to compile a code block will evaluate to a real compile-time error should a code block fail to evaluate.

Meta-functions can be selected as a candidate or unselected depending on a `true` or `false` statement being present at the end of a functions declaration. The `[[compiles]]` directive can be used in-place of this boolean placeholder to enable or disable a meta-function as a candidate based on a `compiles` code block compiling or not. The code block will evaluate per instantiation of a meta function. All inputs and outputs are considered captured in a `compile` code block's context allowing for compile-time reflection of all types. However, variables captured will never evaluate to values given the code block is never run and is never executed either at runtime nor at compile time. 


````zax
if [[compiles]] { ++value } {
    doSomething()
} else {
    doSomethingElse()
}

metaFunction : ()(input :) [[compiles]] {

    // check if a type is defined
    testedFeature : TestedFeature

    // check if the input argument is compatible and convertible to a simple
    // `Integer` type
    check := input as Integer

} = {
    // ...
}

/*

// metaFunction will evaluate to a `true` indicating the function is
// selectable as a candidate:
metaFunction : ()(input :) true = {
    // ...
}

// or to a `false` indicating the function cannot be selected as a candidate:
metaFunction : ()(input :) false = {
    // ...
}

*/
````


### The `requires` directive

A `requires` directive `[[requires, error]]` evaluates a code block that follows into a compile-time constant of `true` or `false`. A code block that follows a `requires` directive is executed if the code compiles. Failure to compile a code block will result in a code block resolving to `false`. A code block must be capable of running at compile-time.

If `error` is specified then a failure to compile or a `requires` code block returning `false` will cause a compiler error.

Meta-functions can be selected as a candidate or unselected depending on a `true` or `false` statement being present at the end of a functions declaration. A `[[requires]]` directive can be used in place of this boolean placeholder to enable or disable a meta-function as a candidate based on a function's arguments. All inputs and outputs are considered captured in the context allowing for compile-time reflection of the types but the values of any arguments are undefined as any values are typically only available at runtime.

````zax
if [[requires]] { return ++value > 2 } {
    doSomething()
} else {
    doSomethingElse()
}

metaFunction : ()(input :) [[requires]] {
    if (size of :input) < (size of Integer)
        return false
    if input is compiled constant {
        // cannot examine the value of `input` if not a compile time constant
        if input < 0
            return false
        return true
    }
    return true
} = {
    // ...
}

/*

// metaFunction will evaluate to a `true` indicating the function is selectable
// as a candidate:
metaFunction : ()(input :) true = {
    // ...
}

// or to a `false` indicating the function cannot be selected as a candidate:
metaFunction : ()(input :) false = {
    // ...
}

*/
````


### The `concept` directive

A `concept` directive has two forms: `[[concept, error]]` and `[[concept=<function>, error]]`. A `concept` is similar to a `requires` directive but instead causes a `final` function to be treated as a type check for the sake of meta-programming. A `concept` directive will evaluate whenever a `concept` function name is used as a meta-type declared with `[[concept]]` on a meta-function. Inside a `concept` function, code is executed at compile-time to evaluate if a meta-type is compatible with an input or output argument at compile type. A `concept` function must return `true` or `false` to indicate if a meta-type is compatible with a `concept`.

The form `[[concept, error]]` is declared on the final function indicating the current function is a concept. The second form `[[concept=<function>, error]]` is declared on a meta-type on a meta-function to indicate if a type should be selected.

A `concept` directive can use `if` clauses with a `compiles` clauses to further evaluate compile-time without execution of any statements.

Functions using a `concept` have a single input argument representing the type to be evaluated and must evaluate to `true` or a meta-function cannot be selected. A variable passed into a meta-function is not initialized, never constructed, and never destructed and is a placeholder to contain the evaluated type. This value can further evaluated in a `compiles` directive to test if various operations would succeed if the value was real.

If `error` is specified then the failure to compile or returning false will cause a compiler error.


````zax
IsSelectable$(Type) final : (result : Boolean)(ignored : $Type) [[concept]] = {
    if ![[compiles]] {
        ++ignored
        --ignored
        ignored += 5
        ignored -= 5
    } return false
    if size of $Type > size of U32
        return false
    return true
}

myFunc$(UseSimpleType [[concept=IsSelectable]]) final : ()(bar : $UseSimpleType) = {
    // ...
}

myFunc final : ()(bar : ) = {
    // ...
}

myFunc(5 as U8)     // first `myFunc` used as it's the most specific evaluation
myFunc(5 as U64)    // last `myFunc` used as the first is not a candidate
````


### The `execute` directive

The `execute` directive `[[execute=<type>]]` evaluates and runs a code block at compile-time.

Types are as follows:
* `generate` - the functional code block will evaluate the input arguments at compile-time and generate new code as a substitute for the code block (i.e. code emits tokens as a string)
* `delegate` - the functional code block will not evaluate any input arguments but rather the code will generate new code as a substitute for the code block at compile-time (i.e. code emits tokens as a string)
* `compile` - the code block will evaluate to constant data of compatible type to the context required and expects compile type constants to be passed into the function
* `dual` (default) - the code block will execute if the values passed in are compile-time constants, or will evaluate to runtime code if the values passed in are not compile-time compatible
* `runtime` - the code block will evaluate to runtime code only

````zax
random final : ()() = {
    // ...
}

double final [[execute]] : (result : Integer)(value : Integer) = {
    return value * 2
}

compileItDouble final [[execute=compile]] : (result : Integer)(value : Integer) = {
    return value * 2
}

generateItDouble final [[execute=generate]] : (result : String)(value : Integer) = {
    // code here generates a string result which becomes parsed into tokens
    // which replaces the function call ...
    return result
}

doubleNow final [[execute]] [[resolve=now]] : (result : Integer)(value : Integer) = {
    return value * 2
}

generateSomething1 final [[execute=generate]] : (result : String)(...) = {
    // code here generates a string result based on examining the compile-time
    // evaluated inputs and the output string result is parsed into tokens which
    // replaces the function call ...
    return result
}

generateSomething2 final [[execute=delegate]] : (
    result : String
)(
    inputs : String[]
) = {
    // this specific form of `delegate` causes each value passed into the string
    // to not be resolved and the output string result is parsed into tokens
    // which replaces the function call ...
    return result
}

// invoking `double` in this context causes it to execute at compile-time
// as no runtime variables are passed in
four := double(2)

// invoking `compileItDouble` in this context causes it to execute at
// compile-time as the compiler will generate complete code for all the
// execution required to run the function
value1 := compileItDouble(random())

// invoking `generateItDouble` in this context causes it to generate replacement
// code tokens for each combination of the types specified
value2 := generateItDouble(random())

// forward declare the `seven` symbol
seven :: forward variable

// ERROR: not all of the terms are able to evaluate at this time;
// `[[resolve=now]]` is forcing order to matter where normally order
// resolution of `seven` would be okay to resolved later;
sevenDouble := doubleNow(seven)

// the seven symbol declared later
seven := 7

value2 = generateSomething1(value2)     // `generateSomething1(value2)` will
                                        // be replaced with alternative tokens

// the entire line below will be replaced with generated tokens and the inputs
// will not be be evaluated; each input will be converted to a string in
// an array representing each argument as a single string in the array
generateSomething2(value2 * 5, "hello")
````


### The `resolve` directive

The `resolve` directive `[[resolve=<option>, retry=<true/false>]]` indicates to the compiler when the specific `import`, `type` statements and `execute`, `compile`, `requires`, and `concept` directives must be resolved.

Options are:
* `trial` (default) - attempt to resolve the declaration now
* `lazy` - only attempt to resolve the declaration if it is referenced
* `last` - only attempt to resolve the declaration at the last instance possible (all `last` directives are done in sequence they are found unless they are found to not resolve and then they are pushed to the back of the resolve queue)
* `now` - immediately resolve the declaration and assume all terms required to evaluate must already be defined at this point

Retry options are:
* `true` - (default for all but `now`) if the resolution fails, retry the resolve at a later time
* `false` - (default for only `now`) if the resolution fails, consider the declaration unresolvable


### The `align` directive

The `align` directive `[[align=<n>, reorder=<option>]]` forces contained types within a type to be aligned at specific memory byte addresses where the memory address modulus the alignment must be 0. By default, the alignment is decided by the compiler. Non-power of 2 addresses are not supported and will cause a `bad-alignment` error.

A `reorder` option is available to indicate the values in the type that follow can be any order chosen by the compiler with the order priority given to the chosen `reorder` option.

The alignment accepts:
* `<n>` - values of 2^N where N >= 0 (default is the CPU's alignment)

Reorder options are:
* `none` (default) - disable reordering for values that follow
* `compact` - reordering the types for compactness
* `speed` - reorder the types for maximum speed

````zax
MyType :: type {
    [[align=1]]
    value1 : Integer
    value2 : Float

    [[align=16]]
    value3 : Uuid
}

MyOtherType :: type {
    [[align, reorder=compact]]
    value1 : Byte
    value2 : Integer
    value3 : Float
    condition : Boolean

    [[align, reorder=none]]
    value4 : String
    value5 : ()()
}
````


### The `reserve` directive

The `reserve` directive `[[reserve=<n>, initialize=<n>]]` forces bytes to be reserved into a type which have no value associated with the space. The `initialize` option allows a value to be pre-filled into the reserved memory.

````zax
MyPacket :: type {
    size : Integer
    [[reserve=1022]]
}

MyPing :: type {
    size : Integer
    id : Uuid
    [[reserve=256, initialize=0]]
}
````


### The `void` directive

The `void` directive `[[void]]` declares a type that has a memory offset into a type as if the contained value existed but the size of the container type does not reserve any bytes for the type with the `void` directive declared.

````zax
assert final : ()(condition : Boolean) = {
    // ...
}

MyPacket :: type {
    [[align=1]]
    size : Integer
    id : Uuid

    fingerprint [[void]] : Uuid
    bytes [[void]] : Byte[1024]
}

// this assert should be `true`
assert(size of MyType == size of Integer + size of Uuid)
````


### The `likely` / `unlikely` directive

The `likely` and `unlikely` directive indicates which `if` path or `switch` statements are `likely` or `unlikely` to occur to help with compiler optimizations and CPU branching. Attempting to specify both `if` paths are `likely` or `unlikely` will result in an `incompatible-directive` error.

The `switch` statement can have one or more case statements marked as `likely` or `unlikely` but not all with the same marking. This will tell the compiler to arrange checks in the most optimal way for these scenarios. If a `switch` is done with alternative operators, the order of the tests is fixed and but the `likely` or `unlikely` may offer hints to the compiler to optimize for some scenarios so long as the test order is not compromised.

On a `switch`, the directive applies to the `case` statement not the `case` statement's code. This is done because the optimization is for each individual case test and not on the destination code path. Because of `case` fallthrough, one `case` may be `likely` and another `unlikely` for the same executed code path.

Using the directive with the `if` statement:

````zax
doSomething final : ()() = {
    // ...
}

doSomethingElse final : ()() = {
    // ...
}

func final : ()() = {
    condition final : (result : Boolean)() = { return true }
    failure final : (result : Boolean)() = { return false }

    // placing the `likely` directive prior to the execution block after the
    // `if` treats the `true` condition as `likely`
    if condition() [[likely]]
        doSomething()
    else
        doSomethingElse()

    // placing the `unlikely` after the `else` statement treats the
    // `false` condition as as `unlikely`
    if condition()
        doSomething()
    else [[unlikely]]
        doSomethingElse()

    if failure() [[unlikely]]
        return
    
    // ...
}
````

Using the directive with the `switch` statement:

````zax
doSomething : ()() = {
    // ...
}

func final : ()(value : Integer) = {
    switch value {
        case 1 [[likely]]
            doSomething()
        case 2
            doSomething()
        case 3 [[likely]]
        case 4 {
            doSomething()
        }
        case 5
        case 6
            doSomething()
        case 7
        case 8
        default [[unlikely]] {
            doSomething()
        }
    }
}
````


### The `always` and `never` directives

The `[[always]]` and `[[never]]` directives indicate to the compiler a code path will always be followed or never be followed. This allows references to code to exist but the paths will be optimized to always follow a code path or to never follow a code path. The compiler may issue an `impossible-if-value` panic if an explicit or implicit `[[never]]` code path was followed.

When `[[never]]` is applied to a `case` statement in a `switch`, the `case` will be treated as an impossible value and the case will be eliminated. This feature can be useful to ensure all enumerators are explicitly handled but to also indicate to the compiler that certain cases can never happen. The compiler may issue an `impossible-switch-value` panic if the value is found.

When `[[always]]` is applied to a `case` statement in a `switch`, the `case` will be treated as the only possible value that could occur. The compiler will issue an `impossible-switch-value` panic if any other `case` is ever found.

Using the directive with the `if` statement:

````zax
doSomething final : ()() = {
    // ...
}

doSomethingElse final : ()() = {
    // ...
}

func final : ()() = {
    condition final : (result : Boolean)() = { return true }
    failure final : (result : Boolean)() = { return false }

    // placing the `always` directive prior to the execution block after the
    // `if` treats the `true` condition as if the result would `always` be true
    if condition() [[always]]
        doSomething()
    else
        doSomethingElse()

    // placing the `always` directive after the `else` statement treats the
    // `false` condition as as `always` the path to follow
    if condition()
        doSomething()
    else [[always]]
        doSomethingElse()

    if failure() [[never]]
        return
    
    // ...
}
````

Using the directive with the `switch` statement:

````zax
doSomething final : ()() = {
    // ...
}

func final : ()(value : Integer) = {
    switch value {
        case 1 [[never]]
            doSomething()
        case 2
            doSomething()
        case 3 [[never]]
        case 4 {
            doSomething()
        }
        case 5
        case 6
            doSomething()
        case 7
        case 8
        default {
            doSomething()
        }
    }
}
````


#### The `never` directive in code flow

The `[[never]]` directive can be used to mark code flows which are impossible to reach. This will allow the compiler to not generate output for code paths that cannot happen. A panic `impossible-code-flow` may be issues if the code flow was followed even though it's not possible to reach (if not explicitly disabled).

Example of an impossible code path:

````zax
print final : ()(...) = {
    // ...
}

random final : (result : Integer)() = {
    // ...
}

forever {
    value := random()

    if value >= 0 {
        print("outcome is likely")
        continue
    }

    if value < 0 {
        print("outlook not so good")
        continue
    }

    // cannot reach here; an integer must be either be >= 0 or < 0
    [[never]]
}
````


### The `return` directive

The `return` directive `[[return=<option>]]` indicates to the compiler how the compiler should code generation regarding the `return` statement.

Options are as follows:
* `never` - the function never returns and the compiler can generate jump assembly instructions without instruction pointer stack frame pushes or return instructions
* `interrupt` - the function will be called directly from an interrupt and the compiler should generate interrupt return instructions instead of standard return instructions

````zax
doForever final : ()() [[return=never]] = {
    // ...
}

doForever()

[[never]]
````


### The `export` directive

The `export` directive `[[export=<option>]]` tells the compiler to apply the export keyword to all exportable types found, or disable a previous `export` directive.

The options are:
* `always` - all exportable types are automatically exported after this directive
* `never` (default option) - disable the exporting of all exportable types after this directive
* `yes` - (default if no `export` option specified) the next type or declared variable is exported
* `no` -  the next type or declared variable is not exported
* `push` - push the current `export` state onto the stack
* `pop` - pop the previous `export` state from the stack

````zax
[[export=always]]
foo : Integer

MyType :: type {
    // ....
}

[[export=never]]
myPrivateData : Integer

MyPrivateType :: type {
    // ...
}

[export] \
visibleToImports : Boolean = true
````


### Literal directives

The `[[compiler,<sub-value>,<option>]]`, `[[module,<sub-value>,<option>]]`, `[[file,<sub-value>,<option>]]` represent string or numerical literals related to the compilation, module, or compiled file. Short forms of `[[file]]`, `[[line,increment=<n>]]`, `[[function]]` exist for `[[file,default]]`, `[[file,line,increment=<n>]]`, and `[[file,function]]` relatively.

If a function is inlined then the represented values become the inline values from where the directives were inlined into and not the inlined values of the function being inlined (and possibly recursively if inlined functions were inturned inlined). If any of these values are not applicable, an empty string literal or default numerical value of 0 is used in its place.

The following literals are relative to the compilation using the `compiler` directive:
* `time` - the time of compilation (as string or as an integer value)
* `date` - the date of compilation (as string)
* `compiler` - the brand name of the compiler application compiling the source code
* `version` - the compiler's version

The following literals are relative to the current module using the `module` directive:
* `location` - URL for the current module (as string)
* `git` - the following option are available for the `git` type:
    * `default` - (default) becomes the literal value `true` if the current module uses git, otherwise `false`
    * `tag` - the current module git tag (as string)
    * `branch` - the current module git branch (as string)
    * `commit` - the current module last git commit hash (as string)
* `path` - the full path to the current module as located on the host file system
* `import-version` - the api version requested for the module being imported
* `hash` - the current hash used to define the current importation definitions

The following literals are relative to the current compiling file using the `file` directive:
* `default` - (default) the source code file being compiled (as string)
* `path` - the source path for the current file (relative to the module root)
* `line` - the line number being compiled (as an integer)
    * an additional `increment=n` option is available on the line literal
* `function` - the function being compiled (as string)
* `date` - the file date of the file being compiled (as string)
* `time` - the file time of the file being compiled (as string or as an integer value)
* `generator` - the name of the generator of the current file, otherwise an empty string (as string)
* `hash` - the current hash of the source file (as string)

The options for `compiler.version` and `module,import-version` are:
* `default` - (default if not specified) the full semantic version as a string
* `major` - the major version number (as Integer)
* `minor` - the minor version number (as Integer)
* `patch` - the patch version number (as Integer)
* `pre-release` - the pre-release (as string)
* `build` - the build identifiers (as string)

The options for `[[compiler,time,<option>]]` and `[[file,time,<option>]]` are:
* `default` - (default if not specified) the full time as a string
* `unix` - the compile-time number of seconds since the unix epoch (as I64)
* `nt` - the compile-time expressed as the number of 100 nanoseconds since the NT time epoch (as I64)

The line directive `[[line=<n>, increment=<n>]]` indicates the current's source's line number. The `increment` argument indicates how much to `increment` the counted line number of for per line of the currently compiled source file (default for `increment` is `1`).

````zax
print final : ()(...) = {
    // ...
}

trace final [[inline=always]] : ()() = {
    currentFile := [[file]]
    currentLine := [[line]]
    currentFunction := [[function]]

    print(currentFile, currentLine, currentFunction)
}

trace()
````


### Override literal directives

All the literal directives can be overridden for a given module, compilation file, or compilation. This allows literals to be changed for generated files, or for the purpose of tweaking some of the values related to the compilation process.

For example, generated source files can use a file/line directives `[[file="<name>"]]` indicates to a compiler the current source was generated by some process using another file as input. The name indicates the path to that original file. The line directive `[[line=<n>, increment=<n>]]` can be used to track an original source's line number so the generated output's line number match an original source file's line numbering rather than a generated output's line number. The `increment` argument indicates how much to increment the counted line number of the original source file per output line found in the file being compiled (whose default is `1`).

The `line` directive will reuse the last `file` directive (which must be present at least once within the same source file being compiled).

Each file currently being compiled will have its own literals for properties relative to the current compiling file. Other literals are relative to a current module and do not change per compiled file (but do change per compiled module). Finally other literals are entirely global to the compilation process.

````zax
// override URL location for a generated module
[[module,location="https://exmplae.com/"]]

[[file,generator="Acme FooBar Generator"]]

// example file generated by Acme FooBar Generator
[[file="inputs.csv"]]

[[line=21]]
apple : Integer
banana : Float
carrot : String

[[line=400, increment=0]]
donut : Float
egglessChocolateMousse : String

[[line=401, increment=0]]
fudge : Integer
gulabJamun : String
````


### `lock-free` directive

The `once` keyword will automatically generate thread safe barriers around a singleton's instance construction to ensure only a single instance will ever be constructed regardless of the threads accessing. However, this is additional overhead that might not always be necessary. The `[[lock-free]]` directive disables the creation of this protective code around a singleton instance creation and assumes that construction of a type will happen entirely single threaded without any possibility of multiple threads competing for an instance creation.

````zax
MyType :: type {
    value1 : String
    value2 : String 
}

giveMeMyType final : (myType : MyType &)() = {
    // no thread locking mechanism will surround this code
    singleton once [[lock-free]] : MyType
    return singleton
}

// force initialization globally on startup (which must be single threaded)
initializeMyType private := giveMeMyType()
````


### `synchronous` directive

For `promise`, `task` or `channel` declared functions, those function are assumed to be implicitly `[[asynchronous]]`. This default can be overridden by using the `synchronous` directive `[[synchronous]]`. When the `synchronous` directive is used, a function is no longer operating asynchronously and all assumptions about any `asynchronous` intentions are no longer present. The `[[synchronous]]` directive effectively changes the expectation of a function from `asynchronous` to `synchronous` and indicates the code path does not need to be thread-aware.

The implicit assumption for `asynchronous` functions is that pass by-values arguments must be qualified as `deep`. The compiler issues an `asynchronous-not-deep` warning on `asynchronous` functions for any pass by-value arguments that are not explicitly qualified as `deep` (or pre-qualified as `deep` based on the type's definition). This check is done to ensure that types potentially crossing a thread boundary are automatically `deep` copied in an effort to prevent concurrency issues. A function can be labelled explicitly as `deep` or `shallow` to suppress this warning by forcing semantics on the arguments.

If a `promise`, `task`, or `channel` declared function will never be used from a different thread contexts then the `[[synchronous]]` directive can be used to acknowledge the `promise`, `task`, or `channel` declared function are exclusively synchronously accessed and thus a `deep` qualifier need not be applied. Further, any type declared as `deep` (which normally would cause a `deep` copy to occur) will perform instead a `shallow` copy of that type (for that `promise`, `task`, or `channel` call). Individual arguments for promises or tasks declared as `deep` explicitly will still perform `deep` copies of arguments.

If a `promise` or `task` truly is `asynchronous` (as it is implicitly defaulted) but the pass by-value should only be `shallow` copied, then the `shallow` qualifier can be specified. This changes the pass by-value from being implicitly a `deep` copy to explicitly being a `shallow` copy and the `asynchronous-not-deep` warning will be suppressed for that argument.

The `[[synchronous]]` and `[[asynchronous]]` are mutually exclusive and they indicate opposite code intentions.


````zax
MyType :: type {
    value1 : Integer * @
}

func final : ()(myType : MyType) promise [[synchronous]] = {
    // ...
}

myType : MyType

// OKAY: the warning `asynchronous-not-deep` will not be issued
later := func(myType)

// ...

// must be called from the same thread or undefined behaviors may result
callable := later.then = { /* ... */ }
callable()
````


### `asynchronous` directive

Unlike a `promise` or a `task`, functions are assumed to operate as `[[synchronous]]`. Using the `[[asynchronous]]` directive tells the compiler that a function will perform asynchronous operations despite not being a `promise` or `task` which are by default assumed to be labelled `[[asynchronous]]` implicitly.  The `[[asynchronous]]` directive effectively changes the expectation of the function from `synchronous` to `asynchronous` and indicates the code is designed to be thread-aware.

When a function is labelled as `asynchronous`, a function is excepted that all pass by-value arguments are qualified with the `deep` specifier. The compiler will issue an `asynchronous-not-deep` warning if the `deep` qualifier is missing (as normally values are implicitly `shallow`). Adding the `deep` qualifier will override the default `shallow` behavior. If the values should be `shallow` copied then the `shallow` qualifier can be used either on the individual pass by-value argument or on the function as a whole.

The `[[synchronous]]` and `[[asynchronous]]` are mutually exclusive and indicate opposite code intentions.


````zax
MyType :: type {
    // ...
}

// functions labelled as `asynchronous` expects all pass by-value functions
// to use the `deep` qualifier rather than the implicit `shallow` thus a
// warning is issued to indicate the oversight
func1 final : ()(myType : MyType) [[asynchronous]] = {
    // ...
}

// the pass by-value is `shallow` copied explicitly thus no warning is issued
func2 final : ()(myType : MyType shallow) [[asynchronous]] = {
    // ...
}

// the pass by-value is `deep` copied thus no warning is issued
func3 final : ()(myType : MyType deep) [[asynchronous]] = {
    // ...
}

// all pass by-values are `shallow` copied thus no warning is issued
func4 final : ()(a : MyType, b : MyType) shallow [[asynchronous]] = {
    // ...
}

// all pass by-values are `deep` copied thus no warning is issued
func5 final : ()(a : MyType, b : MyType) deep [[asynchronous]] = {
    // ...
}
````


### `variables` and `types` mutability defaults directive

#### `variables` default directive

The `[[variables=<options>]]` directive declares defaults for the declaration of all variables. See the [mutability](mutable.md) section for more details. This directive only applies to all source code following the directive and does not change the defaults for any imported modules.

The options are:
* `final` - all declared variable are `final`
* `varies` (default) - all declared variables are declared as `varies`
* `mutable` - all declared variables are `mutable`
* `immutable` (default) - all declared variables are `immutable`
* `push` - push the current `variables` state onto the stack
* `pop` - pop the previous `variables` state from the stack


Example of how `varies` / `final` default applied to variables:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[variables=varies]] 

x1 := 5
x1 = 6          // OKAY

x2 final := 5
x2 = 6          // ERROR: variable value is `final`

x3 varies := 5
x3 = 6          // OKAY

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 final : MyType
mx2.value1 = 6  // OKAY

mx3 varies : MyType
mx3.value1 = 6  // OKAY


[[variables=final]]

y1 := 5
y1 = 6          // ERROR: variable value is `final`

y2 final := 5
y2 = 6          // ERROR: variable value is `final`

y3 varies := 5
y3 = 6          // OKAY

my1 : MyType
my1.value1 = 6  // OKAY

my2 final : MyType
my2.value1 = 6  // OKAY

my3 varies : MyType
my3.value1 = 6  // OKAY
````

Example of how `mutable` / `immutable` default applied to variables:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[variables=immutable]] 

x1 := 5
x1 = 6          // OK (immutable variables respect a type's mutability)

x2 : constant = 5
x2 = 6          // ERROR: type is `constant`

x3 : inconstant = 6
x3 = 6          // OK (immutable variables respect a type's mutability)

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 final : MyType constant
mx2.value1 = 6  // ERROR: type is `constant`

mx3 varies : MyType inconstant
mx3.value1 = 6  // OKAY


[[variables=mutable]]

y1 := 5
y1 = 6          // OKAY

y2 : constant = 5
y2 = 6          // OKAY (type is constant but value is mutable)

y3 : inconstant = 6
y3 = 6          // OKAY

my1 : MyType
my1.value1 = 6  // OKAY

my2 final : MyType constant
my2.value1 = 6  // OKAY (type is constant but values are mutable)

my3 varies : MyType inconstant
my3.value1 = 6  // OKAY
````


#### `types` default directives

The `[[types=<options>]]` directive declares defaults for the declaration of all types (and not a type's definition). See the [mutability](mutable.md) section for more details. This directive only applies to all source code following the directive and does not change the defaults for any imported modules.

The options are:
* `mutable` - (default) if a default is not specified for a type, a declared type is assumed to be `mutable`
* `immutable` - if a default is not specified for a type, a declared type is assumed to be `immutable`
* `constant` - if a `mutable` type is declared, the type is assumed to be `constant` once constructed
* `inconstant` - (default) if a `mutable` type is declared, the type is assumed to remain `mutable` (unless `constant` is applied)
* `push` - push the current `types` state onto the stack
* `pop` - pop the previous `types` state from the stack


Example of how `mutable` / `mutable` default applied to types:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[types=mutable]] 

x1 := 5
x1 = 6          // OKAY

x2 : mutable = 5
x2 = 6          // OKAY

x3 : immutable = 5
x3 = 6          // ERROR: type is immutable

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 : MyType mutable
mx2.value1 = 6  // OKAY

mx3 : MyType immutable
mx3.value1 = 6  // ERROR: type is immutable


[[types=immutable]]

y1 := 5
y1 = 6          // ERROR: type is immutable

y2 : mutable = 5
y2 = 6          // OKAY

y3 : immutable = 5
y3 = 6          // ERROR: type is immutable

my1 : MyType
my1.value1 = 6  // ERROR: type is immutable

my2 : MyType mutable
my2.value1 = 6  // OKAY

my3 : MyType immutable
my3.value1 = 6  // ERROR: type is immutable
````


Example of how `constant` / `inconstant` default applied to types:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[types=inconstant]] 

x1 := 5
x1 = 6          // OKAY

x2 : inconstant = 5
x2 = 6          // OKAY

x3 : constant = 5
x3 = 6          // ERROR: type is constant

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 : MyType inconstant
mx2.value1 = 6  // OKAY

mx3 : MyType constant
mx3.value1 = 6  // ERROR: type is constant


[[types=constant]]

y1 := 5
y1 = 6          // ERROR: type is constant

y2 : inconstant = 5
y2 = 6          // OKAY

y3 : constant = 5
y3 = 6          // ERROR: type is constant

my1 : MyType
my1.value1 = 6  // ERROR: type is constant

my2 : MyType inconstant
my2.value1 = 6  // OKAY

my3 : MyType constant
my3.value1 = 6  // ERROR: type is constant
````


#### `functions` default directives

The `[[functions=<options>]]` directive declares defaults for the declaration of all functions within types. See the [mutability](mutable.md) section for more details. This directive only applies to all source code following the directive and does not change the defaults for any imported modules.

The options are:
* `constant` - a function declared on a type is `constant` by default
* `inconstant` - (default) a function declared on a type is `inconstant` by default
* `push` - push the current `functions` state onto the stack
* `pop` - pop the previous `functions` state from the stack


Example of how `constant` / `inconstant` default applied to functions:

````zax

[[functions=inconstant]] 

MyType1 :: type {
    value1 : Integer = 5
    value2 : String = "hello"

    func1 : ()() = {
        value1 = 6              // OKAY
    }

    func2 : ()() inconstant = {
        value1 = 6              // OKAY
    }

    func3 : ()() constant = {
        value1 = 6              // ERROR: value1 is `constant`
                                // (as function is constant)
    }
}

[[functions=constant]] 

MyType2 :: type {
    value1 : Integer = 5
    value2 : String = "hello"

    func1 : ()() = {
        value1 = 6              // ERROR: value1 is `constant`
                                // (as function is constant)
    }

    func2 : ()() inconstant = {
        value1 = 6              // OKAY
    }

    func3 : ()() constant = {
        value1 = 6              // ERROR: value1 is `constant`
                                // (as function is constant)
    }
}
````


### `virtual`

For compatibility purposes with C++, a function within a type can declare `final` and `virtual` using the compiler directive `[[virtual]]`. This causes a function to be inserted into a virtual table for a `type` where the `virtual` table for a `type` will be auto-created and auto-maintained.

````zax
MyType :: type {
    func1 final [[virtual]] : ()() * = {
    }

    func2 final [[virtual]] : ()() * = {
    }
}
````


### `tab-stop` directive

The `tab-stop` directive `[[tab-stop=<n>]]` controls the source code tab stop for the tokens that follow. This control what alignment the tab ASCII character (`\t`) is assumed within the source code. Tab stops are reset to the default for each module imported. The default tab stop is `8` unless otherwise specified.

````zax
[[tab-stop=4]]

func : ()() = {
    // ...
}
````
