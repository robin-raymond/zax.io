
# [Zax Programming Language](index.md)

## Compiler Directives

### Official and extended directives

All official supported directives do not start with an `x-` in the directive. Custom compiler directives are prefixed with `x-` in the directive name. Custom directives are ignored if they are not supported.

````zax
// example official directives
variable [[discard]] : Type
[[source="example.zax"]]

// example unofficial directives
func final [[x-bytecode=lacrosse]] : ()()
[[x-bogus="party on dudes!"]]
````


### The `source` directive

The `source` compiler directive `[[source="<path/file.zax>", required=<value>, generated=<yes|no>]]` instructs the compiler to pause compiling the current file and continue compiling tokens from the mentioned file until completely parsed then resume compiling the current file. The `source` directive always locates files relative to the current file. If a path is not found, then the parent of the current path is attempted and so on until the `source` is located or the file is not found (where the compiler will issue an error). Paths are always separated with unix forward slashes ('/'). File names are recommended to be always lowercase and words should be separated with a dash sign (`-`).

An optional argument named `required` is available. If the value is `yes` then the file must be found (default behavior) or the `source-not-found` error will occur. If `required` is `no` then the compiler will ignore this file being absent. If `required` is `warn` then the compiler will issue the `source-not-found` warning. The file extension `zax` is the recommended default extension.

An optional argument named `generated` is available. If the value is `yes`, then the source file needs to be generated by one of the compiler's `execute` directives. Prior to attempting to load and parse the file all `execute` directives that can be fully resolved will evaluate to ensure the generated file is present prior to attempting to load the file. The default value is `no` (and redundant to specify).

The [wildcard character](https://en.wikipedia.org/wiki/Wildcard_character) pattern matching notation is allowed. Multiple matched files are imported in ascending ASCII sort order.

````zax
/*
file.zax
*/

[[source="options.zax", required=warn]]
[[source="graphics/*.zax"]]
[[source="sub-path/sub-file.zax"]]
[[source="generated/keyboardMapping.zax", generated=yes]]
````

````zax
/*
sub-path/sub-file.zax
*/

[[source="options.zax", required=no]]
````


### The `asset` directive

The `asset` compiler directive `[[asset="<path/file.zax>", required=<value>, rename="<new-name>", generated=<yes|no>]]` instructs the compiler copy the file into the output target's assets. The `asset` directive always locates files relative to the current file. If a path is not found, then the parent of the current path is attempted and so on until the `asset` is located or the file is not found (where the compiler will issue an error). Paths are always separated with unix forward slashes ('/').

An optional argument named `required` is available. If the value is `yes` then the file must be found (default behavior) or the `asset-not-found` error will occur. If `required` is `no` then the compiler will ignore this file being absent. If `required` is `warn` then the compiler will issue the `asset-not-found` warning. The file extension `zax` is the recommended default extension.

An optional argument named `generated` is available. If the value is `yes`, then the asset file needs to be generated by one of the compiler's `execute` directives. Prior to attempting to load and parse the file all `execute` directive that can be fully resolved will evaluate to ensure the generated file is present prior to attempting to copy the file. The default value is `no` (and redundant to specify).

The [wildcard character](https://en.wikipedia.org/wiki/Wildcard_character) pattern matching notation is allowed. Multiple matched files are imported in ascending ASCII sort order. If a wild card character is used with the rename option then the same wild card character must be present in the `rename`. All wild card characters in the rename must be present in the same order or the `wild-character-mismatch` error will be issued.

````zax
/*
file.zax
*/

[[asset="intro.wav", required=warn]]
[[asset="graphics/*.png"]]
[[asset="sub-path/example-*.pdf", rename="examples/*.pdf"]]
[[asset="palette.png", generated=yes]]
````

````zax
/*
sub-path/sub-file.zax
*/

[[source="options.zax", required=no]]
````


### The `panic` directive

#### The `panic` function

When a panic occurs, the context's panic function is called (`___.panic(...)`). Normally an error message is displayed for the programmer to understand the panic and then the program terminates due to the unexpected an unhandled condition. The default `panic` function can be replaced with an alternative function.

The panic function is called with an enumeration representing the current error code and a code location type containing the source location of where the error was triggered.


#### The pre-panic check function

When a panic occurs in code that is always compiled in (and cannot be removed by direct compiler directive), the context's pre-panic check function is called (`___.prePanicCheck(...)`). This function accepts an enumeration representing the error where a lookup table can be searched to see if the panic is enabled and a code location type. If the panic is enabled the context's panic function is called. If the panic is suppressed the panic function is never called.

A pointer to the lookup table is maintained within the context object. The compiler will insert code to swap in/out the lookup table pointer to other known compiler states if a code section has different run-time only panic scenarios.


#### Enabling/disabling a compiler panics

Code generation for panic can conditions can be enabled or disabled by using the `[[panic=<option>, registered-<panic-name>]]`. If the compiler compiles-in the `panic` directive, the compiler will enable or disable the compiler panic code generation. All compilers must register their panic options and meanings into a shared authority registry. Experimental non-standard panic names must include an `x-` prefix as part of the panic name. Naming a specific panic is optional. If the compiler panic name is not specified, the directive will apply to all panic conditions.

Caution: disabling panics does not prevent the panic scenario; disabling merely removes additional compiler generated protective code that would call a panic function. Without compiling in panic detection, the code may silently fail with undefined behaviors.

The options for panic conditions are:
* `yes` - enables the panic for only to the current statement
* `no` - disables the panic for only to the current statement
* `always` - enables the panic for all statements that follow
* `never` - disables the panic for all statements that follow
* `default` - enables or disables the panic for all statements that follow according to the compiler's defaults
* `lock` - disallows any imported module from changing a panic states
* `unlock` - allows any imported module from changing a panic states


````zax
randomValue final : (output : S32)() = {
    //...
    return output
}

value := randomValue()

[[panic=no, intrinsic-type-cast-overflow]] \
castedValue1 := value as U16

[[panic=yes, intrinsic-type-cast-overflow]] \
castedValue2 := value cast U8

[[panic=always, intrinsic-type-cast-overflow]]

//...

[[panic=never, intrinsic-type-cast-overflow]]

//...

[[panic=default, intrinsic-type-cast-overflow]]

//...

[[panic=never, x-strange-experimental-panic]]
````


#### Panic `push` and `pop`

The state of all panics can be pushed and popped into a compile stack using the `[[panic=push]]` and `[[panic=pop]]` compiler directives. A push operation will keep a copy of all panic states and push these panic states on the compiler stack. A `pop` operation will take the last pushed compiler panic states and apply these panic states as the current panic states.

Upon importing a module, all panic states are pushed and all panic states are popped at the end of an `import`. This ensures that imported modules cannot affect the panic state of the importing module.

````zax
[[panic=push]]

[[panic=never, intrinsic-type-cast-overflow]]

//... code with the panic checks disabled

[[panic=pop]]
````


#### Panic registry and meanings

The following are registered panic scenarios, default states, and their meaning:
* `out-of-memory` (always)
    * memory was requested to be allocated but insufficient memory exists to fill the request
* `intrinsic-type-cast-overflow` (always)
    * an intrinsic type may overflow during the `as` operator to a type with lower bit sizing
* `string-conversion-contains-illegal-sequence` (always)
    * a string literal conversion was found to contain an illegal character sequence during the conversion process
* `reference-from-pointer-to-nothing` (always)
    * a pointer was converted to a reference but the pointer points to nothing
* `pointer-to-nothing-accessed` (always)
    * a value (or function) was accessed but the pointer points to nothing
* `not-all-pointers-deallocated-during-allocator-cleanup`
    * memory cleanup is being performed but not all the allocated memory from the allocator was deallocated
* `impossible-switch-value` (always)
    * a `switch` statement encounter a value which can never happen (because of the `[[never]]` directive or the `[[always]]` directive)
* `impossible-if-value` (always)
    * an `if` statement encounter a value which can never happen (because of the `[[never]]` directive or the `[[always]]` directive)
* `impossible-code-flow` (always)
    * a code path was followed what was marked as impossible (because of the `[[never]]` directive or the `[[always]]` directive)
* `value-polymorphic-function-not-found`
    * a function supporting value polymorphism was called but none of the pre-condition checks succeeded


### The `deprecate` directive

The deprecation directive `[[deprecate=<option>, context=<context>, error, min="<x.x>", max="<x.x>"]]` can be used to cause API usages to be considered deprecated. Any usages found to be deprecated will issue the `deprecate-directive` warning or error. This directive is useful for allow grace periods to exist when upgrading to access older obsoleted APIs as well as an upgrade process to newer APIs while still maintaining compatibility with an older requested API.


The options for panic conditions are:
* `yes` (default) - enables the deprecation for only to the current statement
* `no` - disables the deprecation for only to the current statement
* `always` - enables the deprecation for all statements that follow
* `never` - disables deprecation for all statements that follow (`min`,`max`, `context` are ignored)

The `error` argument is optional and if specified the warning is forced into an error without the possibility to treat the deprecation as only a warning.

Context for the deprecate warning:
* `import` (default) - only warn on usages from module performing the import
* `all` - any usage of this item is to be treated as deprecated
* `local` - any usage of this item outside the local context is deprecated

The `min` option requires the importing module must declare an import of at least this version to use the API. The `max` option requires the importing module must not declare an import version greater than this version. The compiler will treat versions as [point release](https://en.wikipedia.org/wiki/Point_release) notations. The version can be specified using a `version` `String` declaration in the import statement. The `min` and `max` keywords are generally not used together but they can be.

Only one `always` deprecation can be active at a time. The `never` directive will disable any active `always`. Usage of `never` cannot be declared with `error`, `min`, `max` or `context` as they have no applicability and will issue an `incompatible-directive` error. Individual `yes` or `no` temporarily override any `always` deprecations directives for the active statement. Any active deprecation state will not apply to imported modules. There's no way to push or pop deprecations unlike `panic`, `warning`, or `error` directives.

````zax
[[deprecate]] \
MyOldBadlyDesignedType :: type {
    //...
}

// usage of this type should only be performed when
// requesting this version number at minimum
[[deprecate,min="2.3"]] \
MyShinyNewType :: type {
    //...
}

ValidType :: type {

    // all of the functions and variables below are now obsoleted and
    // cannot be used beyond version 1.1
    [[deprecate=always,error,max="1.1"]]

    mrT80sFunc : ()() = {
        //...
    }

    markyMarkFunc : ()() = {
        //...
    }

    eightTrack : MyOldBadlyDesignedType

    // disable the last `always` deprecation directive
    [[deprecate=never]]


    // this function is deprecated if used accessed outside the local context
    [[deprecate,context=local]] \
    needsRedesignFunc : ()() = {
        //..
    }

    // this function is always warned as being deprecated
    [[deprecate,context=all]] \
    mightNeedThisSoNotReadyToRemoveFunc : ()() = {
        //...
    }

    newerOkayFunc : ()() = {
        //..
    }
}
````


### The `inline` function directives

The `inline` directive ``[[inline]]`` can be used to signal to the compiler when to inline a `final` function directly into code or when to call the function as an explicit function call. By default the compiler will decide if inlining a function is desirable.

````zax
// prefer the function to inline
func1 final [[inline]] : ()() = {
    //...
}

// let the compiler decide if inlining is preferred or not
func2 final [[inline=maybe]] : ()() = {
    //...
}

// only allow the function to be created inline
func2 final [[inline=always]] : ()() = {
    //...
}

// never allow the function to be inlined
func3 final [[inline=never]] : ()() = {
    //...
}
````


### The `discard` directive

#### Functions with `discard` directive on return results

Return result arguments on functions marked as `[[discard]]` may be ignored by the caller and will not require the compiler to enforce capturing of the function call's result. Without this directive the `result-not-captured` warning will occur if a function result is not captured.

````zax
pushToQueue : (
    newQueueSize : Integer
)(
    value : Integer
) = {
    // insert code that pushes to the queue and returns the new queue size
}

// ERROR: The newQueueSize was not captured by the caller and thus will cause
// a compiler error
pushToQueue(42)

// ERROR: Even though the result is acknowledged as existing, the caller must
// capture the result into a variable since the result cannot be discarded
:= pushToQueue(42)

// This is allowed as the value is captured (even if the value is never used)
ignoredResult := pushToQueue(42)


pushToQueueVersion2 : (
    newQueueSize [[discard]] : Integer
)(
    value : Integer
) = {
    return pushToQueue(value)
}

// This is allowed as the value is marked as `[[discard]]` and thus does not
// require the result is captured
pushToQueueVersion2(42 * 2)

// An alternative version which is also allowed where the result type is
// declared with an empty name but not captured into a variable
:= pushToQueueVersion2(42 * 2)
````

Functions with multiple arguments can mark each argument with `[[discard]]` to ensure which arguments must be captured by default and which arguments can be discarded and ignored.

````zax
queuedValue : (value : Integer)() = {
    //...
}

queueSize : (size : Integer)() = {
    //...
}

readNextValue : (
    nextValue : Integer,
    remaining : Integer
)() = {
    return queuedValue(), queueSize()
}

// Allowed sa both results are captured
nextValue:, remaining: = readNextValue()

// ERROR: The function returns two values with no results being marked
// as `[[discard]]` thus both result must be captured
nextValue2 := readNextValue()

// ERROR: Even though an acknowledgement is made of the second argument, the
// argument is still not captured and thus will cause a compiler error
nextValue3:, = 

readNextValueVersion2 : (
    nextValue : Integer,
    remaining [[discard]] : Integer
)() = {
    return queuedValue(), queueSize()
}

// Allowed to `discard` the second return result argument as the value
// is marked as `[[discard]]`
nextValue4 := readNextValueVersion2()

// An alternative allowed version where the second argument is acknowledged
// as existing but is not captured
nextValue5:, = readNextValueVersion2()
````


#### Functions with `discard` directive on input arguments

````zax
func : ()(input : Integer) = {
    // ERROR: The variable named `input` is declared but never used
}

funcVersion2 : ()(input [[discard]] : Integer) = {
    // This is allowed since the input variable is discarded intentionally
}

funcVersion3 : ()([[discard]] : Integer) = {
    // This is allowed as the argument is knowingly not important to capture
    // and may be discarded
}

funcVersion4 : ()(: Integer) = {
    // This is allowed as the argument is knowingly declared with an unnamed
    // variable and thus may be discarded with the need to
    // mark with `[[discard]]`
}

func(42)
funcVersion2(42)
funcVersion3(42)
funcVersion4(42)

// ERROR: An input argument was declared but not acknowledged and thus the
// compiler will issue an error. The `discard` has no impact on the caller
// of the function.
funcVersion2()  // ERROR
funcVersion3()  // ERROR
funcVersion4()  // ERROR
````


#### `discard` directive on local variables

Variables that are declared but never used must be marked as `[[discard]]` or the compiler will generate a `variable-declared-but-not-used` warning. The compiler enforces that all declared named variables are referred to or marked with `[[discard]]`.

````zax
func : (result : Integer)() = {
    return 42
}

print : ()(...) = {
    //...
}

// Allowed since the result is captured and used elsewhere
value := func()
print(value)

// ERROR: If this variable was captured as a result but never used again
// then the compiler will issue an compiler error as all results must have
// defined usage elsewhere.
valueNeverUsed := func()

// Allowed since the result is captured as per requirement of the
// called function and marked as `[[discard]]` to indicate that the value is
// knowingly being tossed out
ignoredValue [[discard]] := func()

// ... insert code that never uses ignoredValue ...
````


#### `discard` on previously declared variables

The discard can be applied to values after declaration which will force the compiler to treat the type as unimportant and not complain if the type was not referenced.

````zax
func : ()(input : Integer) = {
    //...
}

//...

// replace func with a new implementation that ignores the input variable
func = {
    [[discard]] input
    //...
}
````


#### `discard` directive on types

Types declared with the `[[discard]]` directive may be constructed without ever being further referenced. This directive allows a variable of the type to be declared without further referencing the type elsewhere thus suppressing all `variable-declared-but-not-used` warnings for this type.

````zax
MyMutx [[discard]] :: type {
    //...
}

MyLock [[discard]] :: type {
    //...

    +++ final : ()(lock : MyLock&) = {
        //...
    }
}

mutex : MyMutx

// normally `lock` being unreferenced would issue an error but the type is a
// simple RAII type and thus does not need further usage beyond merely
// constructing the value
lock : MyLock = mutex

//... code which never referenced `lock` variable ...
````


### The `compiles` directive

The `compiles` directive `[[compiles=<options>, error]]` evaluates the code block that follows into a compile time constant of `true` or `false`. The code block that follows the compiles directive is never executed.

If `error` is specified then the failure to compile the code will evaluate to a compile time error should the compiled code not evaluate.

Options are as follows:
* `delay` (default) - attempt to compile the code but should it fail (possibly due to types or variables later declared), delay and retry compilation when other terms have evaluated
* `last` - only attempt to compile the code at the last instance possible (all `last` `export` directives are done in sequence they are found unless they are found to not compile and then they are pushed to the back of the compile queue)
* `now` - immediately evaluate the code block as all terms required to evaluate must already be defined at this point of compilation


````zax
if [[compiles]] { ++value } {
    doSomething()
} else {
    doSomethingElse()
}
````


### The `requires` directive

The `requires` directive `[[requires=<options>, error]]` evaluates the code block that follows into a compile time constant of `true` or `false`. The code block that follows the compiles directive is executed if the code compiles. Failure to compile the code will result in the code resolving to `false`. The code must be capable of running at compile time.

If `error` is specified then the failure to compile or returning false will cause a compiler error.

Options are as follows:
* `delay` (default) - attempt to compile and run the code but should it fail (possibly due to types or variables later declared), delay and retry compilation when other terms have evaluated
* `last` - only attempt to compile and run the code at the last instance possible (all `last` `export` directives are done in sequence they are found unless they are found to not compile and then they are pushed to the back of the compile queue)
* `now` - immediately evaluate and run the code block as all terms required to evaluate must already be defined at this point of compilation

Meta-functions can be selected as a candidate or unselected depending on a `true` or `false` statement being present at the end of a functions declaration. The `[[requires]]` directive can be used in place of this boolean placeholder to enable or disable a meta-function as a candidate based on the arguments. All inputs and outputs are considered captured in the context allowing for compile time reflection of the types.


````zax
if [[requires]] { return ++value > 2 } {
    doSomething()
} else {
    doSomethingElse()
}

metaFunction : ()(input :) [[requires]] {
    if (sizeof :input) < (sizeof Integer)
        return false
    return true
} = {
    //...
}

/*

// metaFunction will evaluate to a `true` indicating the function is
// selectable as a candidate:
metaFunction : ()(input :) true = {
    //...
}

// or to a `false` indicating the function cannot be selected as a candidate:
metaFunction : ()(input :) false = {
    //...
}

*/
````


### The `execute` directive

The `execute` directive `[[execute=<option>,<type>]]` evaluates and runs a code block at compile time.

Options are:
* `delay` (default) - attempt to compile the code and run it now but should it fail (possibly due to types or variables later declared), delay and retry compilation when other terms have evaluated
* `last` - only attempt to compile the code at the last instance possible (all `last` `export` directives are done in sequence they are found unless they are found to not compile and then they are pushed to the back of the compile queue)
* `now` - immediately execute the code block as all terms required to evaluate must already be defined at this point of compilation

Types are as follows:
* `generate` - the functional code block will generate new code as a substitute for the code block (i.e. the generator emits code tokens)
* `compile` - the code block will evaluate to constant data of compatible type to the context required and expects compile type constants to be passed into the function
* `runtime` (default) - the code block will execute if the values passed in are compile time constants, or will evaluate to runtime code if the values passed in are not compile time compatible.


````zax
random final : ()() = {
    //...
}

double final [[execute]] : (result : Integer)(value : Integer) = {
    return value * 2
}

compileItDouble final [[execute, compile]] : (result : Integer)(value : Integer) = {
    return value * 2
}

generateItDouble final [[execute, generate]] : (result : Integer)(...) = {
    //... code here generated token which replaces the generator code ...
}

doubleNow final [[execute=now]] : (result : Integer)(value : Integer) = {
    return value * 2
}

// invoking `double` in this context causes it to execute at compile time
// as no runtime variables are passed in
four := double(2)

// invoking `compileItDouble` in this context causes it to execute at
// compile time as the compiler will generate complete code for all the
// execution required to run the function
value := compileItDouble(random())

// invoking `generateItDouble` in this context causes it to generate replacement
// code tokens for each combination of the types specified
value := generateItDouble(random())

// ERROR: not all of the terms are able to evaluate at this time
// `[[execute=now]]` is forcing order to matter where normally order of
// resolution is okay to be resolved later
sevenDouble := doubleNow(seven)

seven := 7
````


### The `align` directive

The `align` directive `[[align=<n>, reorder=<option>]]` forces contained types within a type to be aligned at specific memory byte addresses where the memory address modulus the alignment must be 0. By default, the alignment is decided by the compiler. Non-power of 2 addresses are not supported and will cause a `bad-alignment` error.

A `reorder` option is available to indicate the values in the type that follow can be any order chosen by the compiler with the order priority given to the chosen `reorder` option.

The alignment accepts:
* `<n>` - values of 2^N where N >= 0

Reorder options are:
* `none` (default) - disable reordering for values that follow
* `compact` - reordering the types for compactness
* `speed` - reorder the types for maximum speed

````zax
MyType :: type {
    [[align=1]]
    value1 : Integer
    value2 : Float

    [[align=16]]
    value3 : Uuid
}

MyOtherType :: type {
    [[align, reorder=compact]]
    condition : Boolean
    value1 : Byte
    value2 : Integer
    value3 : Float

    [[align, reorder=none]]
    value4 : String
    value5 : ()()
}
````


### The `reserve` directive

The `reserve` directive ``[[reserve=<n>, initialize=<n>]]` forces bytes to be reserved into a type which have no value associated with the space. The `initialize` option allows a value to be pre-filled into the reserved memory.

````zax
MyPacket :: type {
    size : Integer
    [[reserve=1022]]
}

MyPing :: type {
    size : Integer
    id : Uuid
    [[reserve=256, initialize=0]]
}
````


### The `void` directive

The `void` directive `[[void]]` declares a type that has a memory offset into a type as if the contained value existed but the size of the container type does not include the size of any types with the `void` directive declared.

````zax
assert final : ()(condition : Boolean) = {
    //...
}

MyPacket :: type {
    [[align=1]]
    size : Integer
    id : Uuid

    fingerprint [[void]] : Uuid
    bytes [[void]] : Byte[1024]
}

// this assert should be `true`
assert(sizeof MyType == sizeof Integer + sizeof Uuid)
````


### The `likely` / `unlikely` directive

The `likely` and `unlikely` directive indicates which `if` path or `switch` statements are `likely` or `unlikely` to occur to help with compiler optimizations and CPU branching. Attempting to match both `if` paths are `likely` or `unlikely` will result in an `incompatible-directive` error.

The `switch` statement can have one or more case statements marked as `likely` or `unlikely` but not both. This will tell the compiler to arrange checks in the most optimal way for these scenarios. If a `switch` is done with alternative operators, the order of the tests is fixed and but the `likely` or `unlikely` may offer hints to the compiler to optimize for some scenarios so long as the test order is not compromised.

On a `switch` the directive applies to the `case` statement not the `case` statement's code. This is done because the optimization is for each individual case test and not on the code path. Because of `case` fallthrough, one `case` may be `likely` and another `unlikely` for the same executed code path.

Using the directive with the `if` statement:

````zax
doSomething final : ()() = {
    //...
}

doSomethingElse final : ()() = {
    //...
}

func : ()() = {
    condition final : (result : Boolean)() = { return true }
    failure final : (result : Boolean)() = { return false }

    // placing the `likely` directive prior to the execution block after the
    // `if` treats the `true` condition as `likely`
    if condition() [[likely]]
        doSomething()
    else
        doSomethingElse()

    // placing the `unlikely` after the `else` statement treats the
    // `false` condition as as `unlikely`
    if condition()
        doSomething()
    else [[unlikely]]
        doSomethingElse()

    if failure() [[unlikely]]
        return
    
    //...
}
````

Using the directive with the `switch` statement:

````zax
doSomething : ()() = {
    //...
}

func : ()(value : Integer) = {
    switch value {
        case 1 [[likely]]
            doSomething()
        case 2
            doSomething()
        case 3 [[likely]]
        case 4 {
            doSomething()
        }
        case 5
        case 6
            doSomething()
        case 7
        case 8
        default [[unlikely]] {
            doSomething()
        }
    }
}
````


### The `always` and `never` directives

The `[[always]]` and `[[never]]` directives indicate to the compiler a code path will always be followed or never be followed. This allows references to code to exist but the paths will be optimized to always follow a code path or to never follow a code path. The compiler may issue an `impossible-if-value` if an explicit or implicit `[[never]]` code path was followed.

When `[[never]]` is applied to a `case` statement in a `switch`, the `case` will be treated as an impossible value and the case will be eliminated. This feature can be useful to ensure all enumerators are explicitly handled but to also indicate to the compiler that certain cases can never happen. The compiler may issue an `impossible-switch-value` panic if the value is found.

When `[[always]]` is applied to a `case` statement in a `switch`, the `case` will be treated as the only possible value that could occur. The compiler will issue an `impossible-switch-value` panic if any other `case` is ever found.

Using the directive with the `if` statement:

````zax
doSomething final : ()() = {
    //...
}

doSomethingElse final : ()() = {
    //...
}

func : ()() = {
    condition final : (result : Boolean)() = { return true }
    failure final : (result : Boolean)() = { return false }

    // placing the `always` directive prior to the execution block after the
    // `if` treats the `true` condition as if the result would `always` be true
    if condition() [[always]]
        doSomething()
    else
        doSomethingElse()

    // placing the `always` after the `else` statement treats the
    // `false` condition as as `always` the path to follow
    if condition()
        doSomething()
    else [[always]]
        doSomethingElse()

    if failure() [[never]]
        return
    
    //...
}
````

Using the directive with the `switch` statement:

````zax
doSomething : ()() = {
    //...
}

func : ()(value : Integer) = {
    switch value {
        case 1 [[never]]
            doSomething()
        case 2
            doSomething()
        case 3 [[never]]
        case 4 {
            doSomething()
        }
        case 5
        case 6
            doSomething()
        case 7
        case 8
        default {
            doSomething()
        }
    }
}
````


#### The `never` directive in code flow

The `[[never]]` directive can be used to mark code flows which are impossible to reach. This will allow the compiler to not generate output for code paths that cannot happen. A panic `impossible-code-flow` may be issues if the code flow was followed even though it's not possible to reach (if not explicitly disabled).

Example of an impossible code path:

````zax
print final : ()() = {
    //...
}

random final : (result : Integer)() = {
    //...
}

forever {
    value := random()

    if value >= 0 {
        print("outcome is likely")
        continue
    }

    if value < 0 {
        print("outlook not so good")
        continue
    }

    // cannot reach here; an integer must be either be >= 0 or < 0
    [[never]]
}
````


### The `return` directive

The `return` directive `[[return=<option>]]` indicates to the compiler how the compiler should code generation regarding the `return` statement.

Options are as follows:
* `never` - the function never returns and the compiler can generate jump assembly instructions without instruction pointer stack frame pushes or return instructions
* `interrupt` - the function will be called directly from an interrupt and the compiler should generate interrupt return instructions instead of standard return instructions


### The `export` directive

The `export` directive `[[export=<option>]]` tells the compiler to apply the export keyword to all exportable types found or disable a previous `export` directive.

The options are:
* `default` (default) - export keyword operates as normal (will disable the any previous `always` or `never` `export` directives)
* `always` - all exportable types are automatically exported after this directive
* `never` - disable the exporting of all exportable types after this directive


### The literal directives

The `[[file]]`, `[[line]]`, `[[function]]`, `[[date]]`, `[[time]]`, `[[compiler]]`, `[[version-compiler]]`, and `[[version-import]]` representing string or numerical literals for the currently compiling code. If a function is inlined then the represented values become the inline values where the directives were inlined into. If any of these values are not applicable, and empty string literal is generated in its place.

The following meanings are implied by each directive:
* `file` - the source code file being compiled
* `line` - the line number being compiled
* `function` - the function being compiled
* `date` - the date of compilation
* `time` - the time of compilation
* `compiler` - the compiler application generating the source code
* `version-compiler` - the compiler's version
* `version-import` - the api version requested for the module being imported

The `[[file]]` and `[[line]]` directives have dual meaning. When used without any arguments (as described in the literals directive section), these directives become string or Integer compile time constants. With arguments these directives can be overloaded (as is the case for `file` and `line`).

````zax
print final : ()(...) = {
    //...
}

trace final [[inline=always]] : ()() = {
    currentFile := [[file]]
    currentLine := [[line]]
    currentFunction := [[function]]

    print(currentFile, currentLine, currentFunction)
}

trace()
````


### `lock-free` directive

The `once` keyword will automatically generate thread safe barriers around an instance's construction to ensure that no type instance of the same type will ever be constructed. However, this is additional overhead that might not always be necessary. The `[[lock-free]]` directive disables the creation of this protective code around the instance creation and assumes that the construction of the type will happen entirely single threaded without any possibility of two threads competing for object creation.

````zax

MyType :: type {
    value1 : String
    value2 : String 
}

giveMeMyType : (myType : MyType&)() = {
    // no thread locking mechanism will surround this code
    singleton once [[lock-free]] : MyType
    return singleton
}

// force initialization globally on startup (which must be single threaded)
initializeMyType private := giveMeMyType()
````


### `sequential` directive

When a `promise` or `task` is declared and a by-value type is passed to a function not qualified as `deep`, the compiler will expect that type passed to be declared as `deep` or the compiler will assume an error was made by the programmer. The compiler will assume the function to be thread-unsafe and thus a `task-not-deep` or `promise-not-deep` will be issued. This is done to ensure that types potentially crossing a thread boundary are automatically deep copied in an effort to prevent concurrency issues.

If the `promise` or `task` will never be used from a different thread context then the `[[sequential]]` directive can be used to acknowledge the `promise` or `task` as being exclusively sequentially accessed and thus a `deep` operation will not need to be applied. Further, any type declared as `deep` which normally would cause a `deep` copy to occur would not longer perform `deep` copies of the type for that `promise` or `task` call. Individual arguments for promises or tasks declared as `deep` will still perform `deep` copies.


````zax
MyType :: type {
    value1 : Integer* @
}

func : ()(myType : MyType) promise [[sequential]] = {
    //...
}

myType : MyType

// OKAY: the warning `promise-not-deep` will not be issued
later := func(myType)

// ...

// must be called from the same thread or undefined behaviors may result
later.callable()
````


#### `file` / `line` generate code directive

For generated source files, the file/line directives `[[file="<name>"]]` indicates to the compiler the current source was generated by some process using another file as input. The name indicates the path to that original file. The line directive `[[line=<n>, increment=<n>]]` indicates the original source's line number so the generated output's line number can track the original source. The `increment` argument indicates how much to increment the counted line number of the original source file per output line found in the file being compiled (whose default is `1`).

The `line` directive will reuse the last `file` directive (which must be present at least once within the same source file being compiled).

Other `source` directives found in a generated file will not presume the referenced source file was also generated. Thus the directives only applies to the file being parsed.

````zax
[[file="inputs.csv", line=1]]
// example file generated by Acme Generator

[[line=21]]
apple : Integer
banana : Float
carrot : String

[[line=400, increment=0]]
donut : Float
egglessChocolateMousse : String

[[line=401, increment=0]]
fudge : Integer
gulabJamun : String
````
