
# [Zax Programming Language](index.md)

## Compiler Directives

### Official and extended directives

All officially supported directives must be understood to compile and never start with an `x-` prefix. Custom compiler directives are prefixed with `x-` in the directive name. Custom directives are ignored if they are not supported.

````zax
// example official directives
variable final [[inline]] : ()() = {
    // ...
}
[[source="example.zax"]]

// example unofficial directives
func final [[x-bytecode=lacrosse]] : ()()
[[x-bogus="party on dudes!"]]
````


### The `source` directive

The `source` compiler directive `[[source="<path/file.zax>", required=<yes|no|warn>, generated=<yes|no>]]` instructs the compiler to pause compiling the current file and continue compiling tokens from the mentioned file until completely parsed then resume compiling the current file. The `source` directive always locates files relative to the current file. If a path is not found, then the parent of the current path is attempted and so on until the `source` is located or the file is not found (where the compiler will issue an error). Paths are always separated with unix forward slashes ('/'). File names are recommended to be always lowercase and words should be separated with a dash sign (`-`).

An optional argument named `required` is available. If the value is `yes` then the file must be found (default behavior) or the `source-not-found` error will occur. If `required` is `no` then the compiler will ignore this file being absent. If `required` is `warn` then the compiler will issue the `source-not-found` warning. The file extension `zax` is the recommended default extension.

An optional argument named `generated` is available. If the value is `yes`, then the source file needs to be generated by one of the compiler's `execute` directives. Prior to attempting to load and parse the file all `execute` directives that can be fully resolved will evaluate to ensure the generated file is present prior to attempting to load the file. The default value is `no` (and redundant to specify).

The [wildcard character](https://en.wikipedia.org/wiki/Wildcard_character) pattern matching notation is allowed. Multiple matched files are imported in ascending ASCII sort order.

````zax
/*
file.zax
*/

[[source="options.zax", required=warn]]
[[source="graphics/*.zax"]]
[[source="sub-path/sub-file.zax"]]
[[source="generated/keyboardMapping.zax", generated=yes]]
````

````zax
/*
sub-path/sub-file.zax
*/

[[source="options.zax", required=no]]
````


### The `asset` directive

The `asset` compiler directive `[[asset="<path/file.zax>", required=<yes|no|warn>, rename="<new-name>", generated=<yes|no>]]` instructs the compiler copy the file into the output target's assets. The `asset` directive always locates files relative to the current file. If a path is not found, then the parent of the current path is attempted and so on until the `asset` is located or the file is not found (where the compiler will issue an error). Paths are always separated with unix forward slashes ('/').

An optional argument named `required` is available. If the value is `yes` then the file must be found (default behavior) or the `asset-not-found` error will occur. If `required` is `no` then the compiler will ignore this file being absent. If `required` is `warn` then the compiler will issue the `asset-not-found` warning. The file extension `zax` is the recommended default extension.

An optional argument named `generated` is available. If the value is `yes`, then the asset file needs to be generated by one of the compiler's `execute` directives. Prior to attempting to load and parse the file all `execute` directive that can be fully resolved will evaluate to ensure the generated file is present prior to attempting to copy the file. The default value is `no` (and redundant to specify).

The [wildcard character](https://en.wikipedia.org/wiki/Wildcard_character) pattern matching notation is allowed. Multiple matched files are imported in ascending ASCII sort order. If a wild card character is used with the rename option then the same wild card character must be present in the `rename`. All wild card characters in the rename must be present in the same order or the `wild-character-mismatch` error will be issued.

````zax
/*
file.zax
*/

[[asset="intro.wav", required=warn]]
[[asset="graphics/*.png"]]
[[asset="sub-path/example-*.pdf", rename="examples/*.pdf"]]
[[asset="palette.png", generated=yes]]
````

````zax
/*
sub-path/sub-file.zax
*/

[[source="options.zax", required=no]]
````


### The `panic` directive

#### The `panic` function

When a panic occurs, the context's panic function is called (`___.panic(...)`). Normally an error message is displayed for the programmer to understand the panic and then the program terminates due to the unexpected an unhandled condition. The default `panic` function can be replaced with an alternative function.

The panic function is called with an enumeration representing the current error code and a code location type containing the source location of where the error was triggered.


#### The pre-panic check function

When a panic occurs in code that is always compiled in (and cannot be removed by direct compiler directive), the context's pre-panic check function is called (`___.prePanicCheck(...)`). This function accepts an enumeration representing the error where a lookup table can be searched to see if the panic is enabled and a code location type. If the panic is enabled the context's panic function is called. If the panic is suppressed the panic function is never called.

A pointer to the lookup table is maintained within the context object. The compiler will insert code to swap in/out the lookup table pointer to other known compiler states if a code section has different run-time only panic scenarios.


#### Enabling/disabling a compiler panics

Code generation for panic can conditions can be enabled or disabled by using the `[[panic=<option>, registered-<panic-name>]]`. If the compiler compiles-in the `panic` directive, the compiler will enable or disable the compiler panic code generation. All compilers must register their panic options and meanings into a shared authority registry. Experimental non-standard panic names must include an `x-` prefix as part of the panic name. Naming a specific panic is optional. If the compiler panic name is not specified, the directive will apply to all panic conditions.

Caution: disabling panics does not prevent the panic scenario; disabling merely removes additional compiler generated protective code that would call a panic function. Without compiling in panic detection, the code may silently fail with undefined behaviors.

The options for panic conditions are:
* `yes` - enables the panic for only to the current statement
* `no` - disables the panic for only to the current statement
* `always` - enables the panic for all statements that follow
* `never` - disables the panic for all statements that follow
* `default` - enables or disables the panic for all statements that follow according to the compiler's defaults
* `lock` - disallows any imported module from changing a panic state
* `unlock` - allows any imported module from changing a panic state

````zax
randomValue final : (output : S32)() = {
    // ...
    return output
}

value := randomValue()

[[panic=no, intrinsic-type-cast-overflow]] \
castedValue1 := value as U16

[[panic=yes, intrinsic-type-cast-overflow]] \
castedValue2 := value cast U8

[[panic=always, intrinsic-type-cast-overflow]]

// ...

[[panic=never, intrinsic-type-cast-overflow]]

// ...

[[panic=default, intrinsic-type-cast-overflow]]

// ...

[[panic=never, x-strange-experimental-panic]]
````


#### Panic `push` and `pop`

The state of all panics can be pushed and popped into a compile stack using the `[[panic=push]]` and `[[panic=pop]]` compiler directives. A push operation will keep a copy of all panic states and push these panic states on the compiler stack. A `pop` operation will take the last pushed compiler panic states and apply these panic states as the current panic states.

Upon importing a module, all panic states are pushed and all panic states are popped at the end of an `import`. This ensures that imported modules cannot affect the panic state of the importing module.

````zax
[[panic=push]]

[[panic=never, intrinsic-type-cast-overflow]]

// ... code with the panic checks disabled

[[panic=pop]]
````


#### Panic registry and meanings

The following are registered panic scenarios, default states, and their meaning:
* `out-of-memory` (always)
    * memory was requested to be allocated but insufficient memory exists to fill the request
* `intrinsic-type-cast-overflow` (always)
    * an intrinsic type may overflow during the `as` operator to a type with lower bit sizing
* `string-conversion-contains-illegal-sequence` (always)
    * a string literal conversion was found to contain an illegal character sequence during the conversion process
* `reference-from-pointer-to-nothing` (always)
    * a pointer was converted to a reference but the pointer points to nothing
* `pointer-to-nothing-accessed` (always)
    * a value (or function) was accessed but the pointer points to nothing
* `not-all-pointers-deallocated-during-allocator-cleanup`
    * memory cleanup is being performed but not all the allocated memory from the allocator was deallocated
* `impossible-switch-value` (always)
    * a `switch` statement encounter a value which can never happen (because of the `[[never]]` directive or the `[[always]]` directive)
* `impossible-if-value` (always)
    * an `if` statement encounter a value which can never happen (because of the `[[never]]` directive or the `[[always]]` directive)
* `impossible-code-flow` (always)
    * a code path was followed what was marked as impossible (because of the `[[never]]` directive or the `[[always]]` directive)
* `lazy-already-complete` (always)
    * an attempt was made to call a `lazy` function that has already returned from the function
* `value-polymorphic-function-not-found` (always)
    * a function supporting value polymorphism was called but none of the pre-condition checks succeeded


### The `deprecate` directive

The deprecation directive `[[deprecate=<option>, context=<context>, error, min="<x.x>", max="<x.x>"]]` can be used to cause API usages to be considered deprecated. Any usages found to be deprecated will issue the `deprecate-directive` warning or error. This directive is useful for allow grace periods to exist when upgrading to access older obsoleted APIs as well as an upgrade process to newer APIs while still maintaining compatibility with an older requested API.


The options for panic conditions are:
* `yes` (default) - enables the deprecation for only to the current statement
* `no` - disables the deprecation for only to the current statement
* `always` - enables the deprecation for all statements that follow
* `never` - disables deprecation for all statements that follow (`context`, `error`, `min`, `max`, are disallowed)

The `error` argument is optional and if specified the warning is forced into an error without the possibility to treat the deprecation as only a warning.

Context for the deprecate warning:
* `import` (default) - only warn on usages from module performing the import
* `all` - any usage of this item is to be treated as deprecated
* `local` - any usage of this item in the local context is deprecated

The `min` option requires the importing module must declare an import of at least this version to use the API. The `max` option requires the importing module must not declare an import version greater than this version. The compiler will treat versions as [point release](https://en.wikipedia.org/wiki/Point_release) notations. The version can be specified using a `version` `String` declaration in the import statement. The `min` and `max` keywords are generally not used together but they can be.

Only one `always` deprecation can be active at a time. The `never` directive will disable any active `always`. Usage of `never` cannot be declared with `error`, `min`, `max` or `context` as they have no applicability and will issue an `incompatible-directive` error. Individual `yes` or `no` temporarily override any `always` deprecations directives for the active statement. Any active deprecation state will not apply to imported modules. There's no way to `push` or `pop` deprecations unlike `panic`, `warning`, or `error` directives.

````zax
[[deprecate]] \
MyOldBadlyDesignedType :: type {
    // ...
}

// usage of this type should only be performed when
// requesting this version number at minimum
[[deprecate, min="2.3"]] \
MyShinyNewType :: type {
    // ...
}

ValidType :: type {

    // all of the functions and variables below are now obsoleted and
    // cannot be used beyond version 1.1
    [[deprecate=always, error, max="1.1"]]

    mrT80sFunc : ()() = {
        // ...
    }

    markyMarkFunc : ()() = {
        // ...
    }

    eightTrack : MyOldBadlyDesignedType

    // disable the last `always` deprecation directive
    [[deprecate=never]]


    // this function is deprecated if used accessed in the local context
    [[deprecate, context=local]] \
    needsRedesignFunc : ()() = {
        // ...
    }

    // this function is always warned as being deprecated
    [[deprecate, context=all]] \
    mightNeedThisSoNotReadyToRemoveFunc : ()() = {
        // ...
    }

    newerOkayFunc : ()() = {
        // ...
    }
}
````


### The `inline` function directives

The `inline` directive ``[[inline=option]]`` can be used to signal to the compiler when to inline a `final` function directly into code or when to call the function as an explicit function call. By default the compiler will decide if inlining a function is desirable.

The following options are available for the inline directive:
* `maybe` (default) - the compiler decides if it is best to `inline` the function or not
* `always` - the compiler is forced to `inline` the function but all variables declared are not visible to the caller's scope
* `descope` - the compiler is forced to `inline` the function and all variables declared are visible to the caller's scope
* `never` - the compiler may never `inline` this function

````zax
// prefer the function to inline
func1 final [[inline]] : ()() = {
    // ...
}

// let the compiler decide if inlining is preferred or not
func2 final [[inline=maybe]] : ()() = {
    // ...
}

// only allow the function to be created inline
func2 final [[inline=always]] : ()() = {
    // ...
    myValue : Integer
    // ...
}

// only allow the function to be created inline
func3 final [[inline=descope]] : ()() = {
    // ...
    myValue : Integer
    // ...
}

// never allow the function to be inlined
func4 final [[inline=never]] : ()() = {
    // ...
}

func1()
func2()
[[descope]] func3() // calling a function with an `[[inline=descope]]`
                    // requires a declaration of `[[descope]]` on the function
                    // or a warning `descope-directive-required` will be issued
func4()

// OKAY: the definition for `myValue` comes from the `[[inline=descope]]`
myValue *= 3

// ...
````


### The `descope` directive

The `descope` directive `[[descope]]` treats an inner scope as part of the outer scope. As such, no destructors will trigger at the end of scope and all variables declared as part of a scope are treated with the same visibility as the outer scope. Variables declared within a `descope` are treated as having been declared as part of the outer scope thus non-polymorphic variables with the same name will cause a `duplicate-symbol` error rather than shadowing the outer variable.

Example when used with an `if` statement:

````zax
[[descope]] if true {
    myValue : U32 = 5
    // ...
} else {
    myValue : U16 = 10
    // ...
}

myValue *= 2
````

Example when used with a normal scope:

````zax
[[descope]] scope my_scope {
    myValue1 : Integer = 6
    myValue2 : Integer = 7
    // ...
}

myValue1 *= 2 + myValue2
````

Example of possible flow control error condition when used with a normal scope:

````zax
[[descope]] scope my_scope {
    myValue1 : Integer = 6

    if true
        break   // ERROR: will issue `scope-flow-control-skips-declaration`
                // as `myValue2` declaration would be skipped

    myValue2 : Integer = 7
    // ...
}

myValue1 *= 2 + myValue2
````


### The `compiles` directive

The `compiles` directive `[[compiles=<options>, error]]` evaluates the code block that follows into a compile time constant of `true` or `false`. The code block that follows the compiles directive is never executed and declarations and definitions within the code block do not become terms.

If `error` is specified then the failure to compile the code will evaluate to a compile time error should the compiled code not evaluate.

Options are as follows:
* `delay` (default) - attempt to compile the code but should it fail (possibly due to types or variables later declared), delay and retry compilation when other terms have evaluated
* `last` - only attempt to compile the code at the `last` instance possible (all `last` `export` directives are done in sequence they are found unless they are found to not compile and then they are pushed to the back of the compile queue)
* `now` - immediately evaluate the code block as all terms required to evaluate must already be defined at this point of compilation

Meta-functions can be selected as a candidate or unselected depending on a `true` or `false` statement being present at the end of a functions declaration. The `[[compiles]]` directive can be used in place of this boolean placeholder to enable or disable a meta-function as a candidate based on the `compiles` code block compiling or not. All inputs and outputs are considered captured in the context allowing for compile time reflection of the types.


````zax
if [[compiles]] { ++value } {
    doSomething()
} else {
    doSomethingElse()
}

metaFunction : ()(input :) [[compiles]] {

    // check if a type is defined
    testedFeature : TestedFeature

    // check if the input argument is compatible and convertible to a simple Integer type
    check := input as Integer

} = {
    // ...
}

/*

// metaFunction will evaluate to a `true` indicating the function is
// selectable as a candidate:
metaFunction : ()(input :) true = {
    // ...
}

// or to a `false` indicating the function cannot be selected as a candidate:
metaFunction : ()(input :) false = {
    // ...
}

*/
````


### The `requires` directive

The `requires` directive `[[requires=<options>, error]]` evaluates the code block that follows into a compile time constant of `true` or `false`. The code block that follows the compiles directive is executed if the code compiles. Failure to compile the code will result in the code resolving to `false`. The code must be capable of running at compile time.

If `error` is specified then the failure to compile or the `requires` code block returning false will cause a compiler error.

Options are as follows:
* `delay` (default) - attempt to compile and run the code but should it fail (possibly due to types or variables later declared), delay and retry compilation when other terms have evaluated
* `last` - only attempt to compile and run the code at the last instance possible (all `last` `export` directives are done in sequence they are found unless they are found to not compile and then they are pushed to the back of the compile queue)
* `now` - immediately evaluate and run the code block as all terms required to evaluate must already be defined at this point of compilation

Meta-functions can be selected as a candidate or unselected depending on a `true` or `false` statement being present at the end of a functions declaration. The `[[requires]]` directive can be used in place of this boolean placeholder to enable or disable a meta-function as a candidate based on the arguments. All inputs and outputs are considered captured in the context allowing for compile time reflection of the types.


````zax
if [[requires]] { return ++value > 2 } {
    doSomething()
} else {
    doSomethingElse()
}

metaFunction : ()(input :) [[requires]] {
    if (sizeof :input) < (sizeof Integer)
        return false
    return true
} = {
    // ...
}

/*

// metaFunction will evaluate to a `true` indicating the function is
// selectable as a candidate:
metaFunction : ()(input :) true = {
    // ...
}

// or to a `false` indicating the function cannot be selected as a candidate:
metaFunction : ()(input :) false = {
    // ...
}

*/
````


### The `concept` directive

The `concept` directive `[[concept=<option>, error]]` is similar to the `requires` directive but instead causes a `final` function to be treated as a type for the sake of meta-programming. The `concept` directive will evaluate the function whenever the function name is used as a type in a meta-function. Inside the `concept` function, code is executed at compile time to evaluate if meta-type is compatible with the input or output arguments at compile type.

The `concept` directive can use `if` clauses with the `compiles` clauses to further evaluate compile time without execution clauses.

Functions using the `concept` have a single input argument representing the type to be evaluated which is unspecified or alternatively another `concept` labelled function type which also must evaluate to true. The variable passed in is not initialized, never constructed, and never destructed and is a placeholder to contain the evaluated type. This value can further evaluated in a `compiles` directive to test if various operations would succeed if the value was real.

If `error` is specified then the failure to compile or returning false will cause a compiler error.

Options are as follows:
* `delay` (default) - attempt to compile and run the code but should it fail (possibly due to types or variables later declared), delay and retry compilation when other terms have evaluated
* `last` - only attempt to compile and run the code at the last instance possible (all `last` `export` directives are done in sequence they are found unless they are found to not compile and then they are pushed to the back of the compile queue)
* `now` - immediately evaluate and run the code block as all terms required to evaluate must already be defined at this point of compilation

````zax
UseSimpleType final : (result : Boolean)(ignored : $Type) [[concept]] = {
    if ![[compiles]] {
        ++ignored
        --ignored
        ignored += 5
        ignored -= 5
    } return false
    if sizeof $Type > sizeof U32
        return false
    return true
}

myFunc final : ()(bar : UseSimpleType) = {
    // ...
}

myFunc final : ()(bar : ) = {
    // ...
}

myFunc(5 as U8)     // first `myFunc` used as it's the most specific evaluation
myFunc(5 as U64)    // last `myFunc` used as the first is not a candidate
````


### The `execute` directive

The `execute` directive `[[execute=<type>]]` evaluates and runs a code block at compile time.

Types are as follows:
* `generate` - the functional code block will generate new code as a substitute for the code block (i.e. the generator emits code tokens)
* `compile` - the code block will evaluate to constant data of compatible type to the context required and expects compile type constants to be passed into the function
* `runtime` (default) - the code block will execute if the values passed in are compile time constants, or will evaluate to runtime code if the values passed in are not compile time compatible.

If `generate` is compiled with the `[[inline=always]]`, the output generated code will emit tokens directly into the scope where the executed function is called.

````zax
random final : ()() = {
    // ...
}

double final [[execute]] : (result : Integer)(value : Integer) = {
    return value * 2
}

compileItDouble final [[execute=compile]] : (result : Integer)(value : Integer) = {
    return value * 2
}

generateItDouble final [[execute=generate]] : (result : Integer)(...) = {
    // ... code here generated token which replaces the generator code ...
}

doubleNow final [[execute]] [[resolve=now]] : (result : Integer)(value : Integer) = {
    return value * 2
}

// invoking `double` in this context causes it to execute at compile time
// as no runtime variables are passed in
four := double(2)

// invoking `compileItDouble` in this context causes it to execute at
// compile time as the compiler will generate complete code for all the
// execution required to run the function
value1 := compileItDouble(random())

// invoking `generateItDouble` in this context causes it to generate replacement
// code tokens for each combination of the types specified
value2 := generateItDouble(random())

// ERROR: not all of the terms are able to evaluate at this time
// `[[resolve=now]]` is forcing order to matter where normally order of
// resolution is okay to be resolved later
sevenDouble := doubleNow(seven)

seven := 7
````


### The `resolve` directive

The `resolve` directive `[[resolve=<option>, retry=<true/false>]]` indicates to the compiler when the specific import, type, execute, or compile statement must be resolved.

Options are:
* `trial` (default) - attempt to resolve the declaration now
* `lazy` - only attempt to resolve the declaration if it is referenced
* `last` - only attempt to resolve the declaration at the last instance possible (all `last` directives are done in sequence they are found unless they are found to not resolve and then they are pushed to the back of the resolve queue)
* `now` - immediately resolve the declaration and assume all terms required to evaluate must already be defined at this point

Retry options are:
* `true` - (default for all but `now`) if the resolution fails, retry the resolve at a later time
* `false` - (default for only `now`) if the resolution fails, consider the declaration unresolvable


### The `align` directive

The `align` directive `[[align=<n>, reorder=<option>]]` forces contained types within a type to be aligned at specific memory byte addresses where the memory address modulus the alignment must be 0. By default, the alignment is decided by the compiler. Non-power of 2 addresses are not supported and will cause a `bad-alignment` error.

A `reorder` option is available to indicate the values in the type that follow can be any order chosen by the compiler with the order priority given to the chosen `reorder` option.

The alignment accepts:
* `<n>` - values of 2^N where N >= 0

Reorder options are:
* `none` (default) - disable reordering for values that follow
* `compact` - reordering the types for compactness
* `speed` - reorder the types for maximum speed

````zax
MyType :: type {
    [[align=1]]
    value1 : Integer
    value2 : Float

    [[align=16]]
    value3 : Uuid
}

MyOtherType :: type {
    [[align, reorder=compact]]
    condition : Boolean
    value1 : Byte
    value2 : Integer
    value3 : Float

    [[align, reorder=none]]
    value4 : String
    value5 : ()()
}
````


### The `reserve` directive

The `reserve` directive `[[reserve=<n>, initialize=<n>]]` forces bytes to be reserved into a type which have no value associated with the space. The `initialize` option allows a value to be pre-filled into the reserved memory.

````zax
MyPacket :: type {
    size : Integer
    [[reserve=1022]]
}

MyPing :: type {
    size : Integer
    id : Uuid
    [[reserve=256, initialize=0]]
}
````


### The `void` directive

The `void` directive `[[void]]` declares a type that has a memory offset into a type as if the contained value existed but the size of the container type does not include the size of any types with the `void` directive declared.

````zax
assert final : ()(condition : Boolean) = {
    // ...
}

MyPacket :: type {
    [[align=1]]
    size : Integer
    id : Uuid

    fingerprint [[void]] : Uuid
    bytes [[void]] : Byte[1024]
}

// this assert should be `true`
assert(sizeof MyType == sizeof Integer + sizeof Uuid)
````


### The `likely` / `unlikely` directive

The `likely` and `unlikely` directive indicates which `if` path or `switch` statements are `likely` or `unlikely` to occur to help with compiler optimizations and CPU branching. Attempting to specify both `if` paths are `likely` or `unlikely` will result in an `incompatible-directive` error.

The `switch` statement can have one or more case statements marked as `likely` or `unlikely` but not all with the same marking. This will tell the compiler to arrange checks in the most optimal way for these scenarios. If a `switch` is done with alternative operators, the order of the tests is fixed and but the `likely` or `unlikely` may offer hints to the compiler to optimize for some scenarios so long as the test order is not compromised.

On a `switch`, the directive applies to the `case` statement not the `case` statement's code. This is done because the optimization is for each individual case test and not on the destination code path. Because of `case` fallthrough, one `case` may be `likely` and another `unlikely` for the same executed code path.

Using the directive with the `if` statement:

````zax
doSomething final : ()() = {
    // ...
}

doSomethingElse final : ()() = {
    // ...
}

func final : ()() = {
    condition final : (result : Boolean)() = { return true }
    failure final : (result : Boolean)() = { return false }

    // placing the `likely` directive prior to the execution block after the
    // `if` treats the `true` condition as `likely`
    if condition() [[likely]]
        doSomething()
    else
        doSomethingElse()

    // placing the `unlikely` after the `else` statement treats the
    // `false` condition as as `unlikely`
    if condition()
        doSomething()
    else [[unlikely]]
        doSomethingElse()

    if failure() [[unlikely]]
        return
    
    // ...
}
````

Using the directive with the `switch` statement:

````zax
doSomething : ()() = {
    // ...
}

func final : ()(value : Integer) = {
    switch value {
        case 1 [[likely]]
            doSomething()
        case 2
            doSomething()
        case 3 [[likely]]
        case 4 {
            doSomething()
        }
        case 5
        case 6
            doSomething()
        case 7
        case 8
        default [[unlikely]] {
            doSomething()
        }
    }
}
````


### The `always` and `never` directives

The `[[always]]` and `[[never]]` directives indicate to the compiler a code path will always be followed or never be followed. This allows references to code to exist but the paths will be optimized to always follow a code path or to never follow a code path. The compiler may issue an `impossible-if-value` panic if an explicit or implicit `[[never]]` code path was followed.

When `[[never]]` is applied to a `case` statement in a `switch`, the `case` will be treated as an impossible value and the case will be eliminated. This feature can be useful to ensure all enumerators are explicitly handled but to also indicate to the compiler that certain cases can never happen. The compiler may issue an `impossible-switch-value` panic if the value is found.

When `[[always]]` is applied to a `case` statement in a `switch`, the `case` will be treated as the only possible value that could occur. The compiler will issue an `impossible-switch-value` panic if any other `case` is ever found.

Using the directive with the `if` statement:

````zax
doSomething final : ()() = {
    // ...
}

doSomethingElse final : ()() = {
    // ...
}

func final : ()() = {
    condition final : (result : Boolean)() = { return true }
    failure final : (result : Boolean)() = { return false }

    // placing the `always` directive prior to the execution block after the
    // `if` treats the `true` condition as if the result would `always` be true
    if condition() [[always]]
        doSomething()
    else
        doSomethingElse()

    // placing the `always` directive after the `else` statement treats the
    // `false` condition as as `always` the path to follow
    if condition()
        doSomething()
    else [[always]]
        doSomethingElse()

    if failure() [[never]]
        return
    
    // ...
}
````

Using the directive with the `switch` statement:

````zax
doSomething final : ()() = {
    // ...
}

func final : ()(value : Integer) = {
    switch value {
        case 1 [[never]]
            doSomething()
        case 2
            doSomething()
        case 3 [[never]]
        case 4 {
            doSomething()
        }
        case 5
        case 6
            doSomething()
        case 7
        case 8
        default {
            doSomething()
        }
    }
}
````


#### The `never` directive in code flow

The `[[never]]` directive can be used to mark code flows which are impossible to reach. This will allow the compiler to not generate output for code paths that cannot happen. A panic `impossible-code-flow` may be issues if the code flow was followed even though it's not possible to reach (if not explicitly disabled).

Example of an impossible code path:

````zax
print final : ()(...) = {
    // ...
}

random final : (result : Integer)() = {
    // ...
}

forever {
    value := random()

    if value >= 0 {
        print("outcome is likely")
        continue
    }

    if value < 0 {
        print("outlook not so good")
        continue
    }

    // cannot reach here; an integer must be either be >= 0 or < 0
    [[never]]
}
````


### The `return` directive

The `return` directive `[[return=<option>]]` indicates to the compiler how the compiler should code generation regarding the `return` statement.

Options are as follows:
* `never` - the function never returns and the compiler can generate jump assembly instructions without instruction pointer stack frame pushes or return instructions
* `interrupt` - the function will be called directly from an interrupt and the compiler should generate interrupt return instructions instead of standard return instructions

````zax
doForever final : ()() [[return=never]] = {
    // ...
}

doForever()

[[never]]
````


### The `export` directive

The `export` directive `[[export=<option>]]` tells the compiler to apply the export keyword to all exportable types found, or disable a previous `export` directive.

The options are:
* `always` - all exportable types are automatically exported after this directive
* `never` (default option) - disable the exporting of all exportable types after this directive
* `yes` - (default if no `export` option specified) the next type or declared variable is exported
* `no` -  the next type or declared variable is not exported
* `push` - push the current `export` state onto the stack
* `pop` - pop the previous `export` state from the stack

````zax
[[export=always]]
foo : Integer

MyType :: type {
    // ....
}

[[export=never]]
myPrivateData : Integer

MyPrivateType :: type {
    // ...
}

[export] \
visibleToImports : Boolean = true
````


### The literal directives

The `[[file]]`, `[[line]]`, `[[function]]`, `[[date]]`, `[[time=<option>]]`, `[[compiler]]`, `[[version-compiler=<option>]]`, and `[[version-import=<option>]]` representing string or numerical literals for the currently compiling code. If a function is inlined then the represented values become the inline values where the directives were inlined into (and possibly recursively so if inlined functions were inturned inlined). If any of these values are not applicable, an empty string literal is generated in its place.

The following meanings are implied by each directive:
* `file` - the source code file being compiled (as string)
* `line` - the line number being compiled (as an integer)
* `function` - the function being compiled (as string)
* `date` - the date of compilation (as string)
* `time` - the time of compilation (as string)
* `compiler` - the compiler application generating the source code
* `version-compiler` - the compiler's version
* `version-import` - the api version requested for the module being imported

The options for `version-compiler` and `version-import` are:
* `default` - (default if not specified) the full semantic version as a string
* `major` - the major version number (as Integer)
* `minor` - the minor version number (as Integer)
* `patch` - the patch version number (as Integer)
* `pre-release` - the pre-release (as string)
* `build` - the build identifiers (as string)

The options for `time` are:
* `default` - (default if not specified) the full time as a string
* `unix` - the compile time number of seconds since the unix epoch (as Integer)
* `nt` - the compile time expressed as the number of 100 nanoseconds since the NT time epoch (as Integer)

The `[[file]]` and `[[line]]` directives have dual meaning. When used without any arguments (as described in the literals directive section), these directives become string or Integer compile time constants. With arguments, these directives can be overload the current value (as is the case for `file` and `line`).

````zax
print final : ()(...) = {
    // ...
}

trace final [[inline=always]] : ()() = {
    currentFile := [[file]]
    currentLine := [[line]]
    currentFunction := [[function]]

    print(currentFile, currentLine, currentFunction)
}

trace()
````


### `lock-free` directive

The `once` keyword will automatically generate thread safe barriers around a singleton's instance construction to ensure only a single instance will ever be constructed regardless of the threads accessing. However, this is additional overhead that might not always be necessary. The `[[lock-free]]` directive disables the creation of this protective code around a singleton instance creation and assumes that construction of a type will happen entirely single threaded without any possibility of multiple threads competing for an instance creation.

````zax
MyType :: type {
    value1 : String
    value2 : String 
}

giveMeMyType final : (myType : MyType &)() = {
    // no thread locking mechanism will surround this code
    singleton once [[lock-free]] : MyType
    return singleton
}

// force initialization globally on startup (which must be single threaded)
initializeMyType private := giveMeMyType()
````


### `synchronous` directive

For `promise`, `task` or `channel` declared functions, those function are assumed to be implicitly `[[asynchronous]]`. This default can be overridden by using the `synchronous` directive `[[synchronous]]`. When the `synchronous` directive is used, a function is no longer operating asynchronously and all assumptions about any `asynchronous` intentions are no longer present. The `[[synchronous]]` directive effectively changes the expectation of a function from `asynchronous` to `synchronous` and indicates the code path does not need to be thread-aware.

The implicit assumption for `asynchronous` functions is that pass by-values arguments must be qualified as `deep`. The compiler issues an `asynchronous-not-deep` warning on `asynchronous` functions for any pass by-value arguments that are not explicitly qualified as `deep` (or pre-qualified as `deep` based on the type's definition). This check is done to ensure that types potentially crossing a thread boundary are automatically `deep` copied in an effort to prevent concurrency issues. A function can be labelled explicitly as `deep` or `shallow` to suppress this warning by forcing semantics on the arguments.

If a `promise`, `task`, or `channel` declared function will never be used from a different thread contexts then the `[[synchronous]]` directive can be used to acknowledge the `promise`, `task`, or `channel` declared function are exclusively synchronously accessed and thus a `deep` qualifier need not be applied. Further, any type declared as `deep` (which normally would cause a `deep` copy to occur) will perform instead a `shallow` copy of that type (for that `promise`, `task`, or `channel` call). Individual arguments for promises or tasks declared as `deep` explicitly will still perform `deep` copies of arguments.

If a `promise` or `task` truly is `asynchronous` (as it is implicitly defaulted) but the pass by-value should only be `shallow` copied, then the `shallow` qualifier can be specified. This changes the pass by-value from being implicitly a `deep` copy to explicitly being a `shallow` copy and the `asynchronous-not-deep` warning will be suppressed for that argument.

The `[[synchronous]]` and `[[asynchronous]]` are mutually exclusive and they indicate opposite code intentions.


````zax
MyType :: type {
    value1 : Integer * @
}

func final : ()(myType : MyType) promise [[synchronous]] = {
    // ...
}

myType : MyType

// OKAY: the warning `asynchronous-not-deep` will not be issued
later := func(myType)

// ...

// must be called from the same thread or undefined behaviors may result
callable := later.then = { /* ... */ }
callable()
````

### `asynchronous` directive

Unlike a `promise` or a `task`, functions are assumed to operate as `[[synchronous]]`. Using the `[[asynchronous]]` directive tells the compiler that a function will perform asynchronous operations despite not being a `promise` or `task` which are by default assumed to be labelled `[[asynchronous]]` implicitly.  The `[[asynchronous]]` directive effectively changes the expectation of the function from `synchronous` to `asynchronous` and indicates the code is designed to be thread-aware.

When a function is labelled as `asynchronous`, a function is excepted that all pass by-value arguments are qualified with the `deep` specifier. The compiler will issue an `asynchronous-not-deep` warning if the `deep` qualifier is missing (as normally values are implicitly `shallow`). Adding the `deep` qualifier will override the default `shallow` behavior. If the values should be `shallow` copied then the `shallow` qualifier can be used either on the individual pass by-value argument or on the function as a whole.

The `[[synchronous]]` and `[[asynchronous]]` are mutually exclusive and indicate opposite code intentions.


````zax
MyType :: type {
    // ...
}

// functions labelled as `asynchronous` expects all pass by-value functions
// to use the `deep` qualifier rather than the implicit `shallow` thus a
// warning is issued to indicate the oversight
func1 final : ()(myType : MyType) [[asynchronous]] = {
    // ...
}

// the pass by-value is `shallow` copied explicitly thus no warning is issued
func2 final : ()(myType : MyType shallow) [[asynchronous]] = {
    // ...
}

// the pass by-value is `deep` copied thus no warning is issued
func3 final : ()(myType : MyType deep) [[asynchronous]] = {
    // ...
}

// all pass by-values are `shallow` copied thus no warning is issued
func4 final : ()(a : MyType, b : MyType) shallow [[asynchronous]] = {
    // ...
}

// all pass by-values are `deep` copied thus no warning is issued
func5 final : ()(a : MyType, b : MyType) deep [[asynchronous]] = {
    // ...
}
````


### `variables` and `types` mutability defaults directive

#### `variables` default directive

The `[[variables=<options>]]` directive declares defaults for the declaration of all variables. See the [mutability](mutable.md) section for more details. This directive only applies to all source code following the directive and does not change the defaults for any imported modules.

The options are:
* `final` - all declared variable are `final`
* `varies` (default) - all declared variables are declared as `varies`
* `mutable` - all declared variables are `mutable`
* `immutable` (default) - all declared variables are `immutable`
* `push` - push the current `variables` state onto the stack
* `pop` - pop the previous `variables` state from the stack


Example of how `varies` / `final` default applied to variables:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[variables=varies]] 

x1 := 5
x1 = 6          // OKAY

x2 final := 5
x2 = 6          // ERROR: variable value is `final`

x3 varies := 5
x3 = 6          // OKAY

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 final : MyType
mx2.value1 = 6  // OKAY

mx3 varies : MyType
mx3.value1 = 6  // OKAY


[[variables=final]]

y1 := 5
y1 = 6          // ERROR: variable value is `final`

y2 final := 5
y2 = 6          // ERROR: variable value is `final`

y3 varies := 5
y3 = 6          // OKAY

my1 : MyType
my1.value1 = 6  // OKAY

my2 final : MyType
my2.value1 = 6  // OKAY

my3 varies : MyType
my3.value1 = 6  // OKAY
````

Example of how `mutable` / `immutable` default applied to variables:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[variables=immutable]] 

x1 := 5
x1 = 6          // OK (immutable variables respect a type's mutability)

x2 : constant = 5
x2 = 6          // ERROR: type is `constant`

x3 : inconstant = 6
x3 = 6          // OK (immutable variables respect a type's mutability)

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 final : MyType constant
mx2.value1 = 6  // ERROR: type is `constant`

mx3 varies : MyType inconstant
mx3.value1 = 6  // OKAY


[[variables=mutable]]

y1 := 5
y1 = 6          // OKAY

y2 : constant = 5
y2 = 6          // OKAY (type is constant but value is mutable)

y3 : inconstant = 6
y3 = 6          // OKAY

my1 : MyType
my1.value1 = 6  // OKAY

my2 final : MyType constant
my2.value1 = 6  // OKAY (type is constant but values are mutable)

my3 varies : MyType inconstant
my3.value1 = 6  // OKAY
````


#### `types` default directives

The `[[types=<options>]]` directive declares defaults for the declaration of all types (and not a type's definition). See the [mutability](mutable.md) section for more details. This directive only applies to all source code following the directive and does not change the defaults for any imported modules.

The options are:
* `mutable` - (default) if a default is not specified for a type, a declared type is assumed to be `mutable`
* `immutable` - if a default is not specified for a type, a declared type is assumed to be `immutable`
* `constant` - if a `mutable` type is declared, the type is assumed to be `constant` once constructed
* `inconstant` - (default) if a `mutable` type is declared, the type is assumed to remain `mutable` (unless `constant` is applied)
* `push` - push the current `types` state onto the stack
* `pop` - pop the previous `types` state from the stack


Example of how `mutable` / `mutable` default applied to types:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[types=mutable]] 

x1 := 5
x1 = 6          // OKAY

x2 : mutable = 5
x2 = 6          // OKAY

x3 : immutable = 5
x3 = 6          // ERROR: type is immutable

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 : MyType mutable
mx2.value1 = 6  // OKAY

mx3 : MyType immutable
mx3.value1 = 6  // ERROR: type is immutable


[[types=immutable]]

y1 := 5
y1 = 6          // ERROR: type is immutable

y2 : mutable = 5
y2 = 6          // OKAY

y3 : immutable = 5
y3 = 6          // ERROR: type is immutable

my1 : MyType
my1.value1 = 6  // ERROR: type is immutable

my2 : MyType mutable
my2.value1 = 6  // OKAY

my3 : MyType immutable
my3.value1 = 6  // ERROR: type is immutable
````


Example of how `constant` / `inconstant` default applied to types:

````zax
MyType :: type {
    value1 : Integer = 5
    value2 : String = "hello"
}

[[types=inconstant]] 

x1 := 5
x1 = 6          // OKAY

x2 : inconstant = 5
x2 = 6          // OKAY

x3 : constant = 5
x3 = 6          // ERROR: type is constant

mx1 : MyType
mx1.value1 = 6  // OKAY

mx2 : MyType inconstant
mx2.value1 = 6  // OKAY

mx3 : MyType constant
mx3.value1 = 6  // ERROR: type is constant


[[types=constant]]

y1 := 5
y1 = 6          // ERROR: type is constant

y2 : inconstant = 5
y2 = 6          // OKAY

y3 : constant = 5
y3 = 6          // ERROR: type is constant

my1 : MyType
my1.value1 = 6  // ERROR: type is constant

my2 : MyType inconstant
my2.value1 = 6  // OKAY

my3 : MyType constant
my3.value1 = 6  // ERROR: type is constant
````


#### `functions` default directives

The `[[functions=<options>]]` directive declares defaults for the declaration of all functions within types. See the [mutability](mutable.md) section for more details. This directive only applies to all source code following the directive and does not change the defaults for any imported modules.

The options are:
* `constant` - a function declared on a type is `constant` by default
* `inconstant` - (default) a function declared on a type is `inconstant` by default
* `push` - push the current `functions` state onto the stack
* `pop` - pop the previous `functions` state from the stack


Example of how `constant` / `inconstant` default applied to functions:

````zax

[[functions=inconstant]] 

MyType1 :: type {
    value1 : Integer = 5
    value2 : String = "hello"

    func1 : ()() = {
        value1 = 6              // OKAY
    }

    func2 : ()() inconstant = {
        value1 = 6              // OKAY
    }

    func3 : ()() constant = {
        value1 = 6              // ERROR: value1 is `constant`
                                // (as function is constant)
    }
}

[[functions=constant]] 

MyType2 :: type {
    value1 : Integer = 5
    value2 : String = "hello"

    func1 : ()() = {
        value1 = 6              // ERROR: value1 is `constant`
                                // (as function is constant)
    }

    func2 : ()() inconstant = {
        value1 = 6              // OKAY
    }

    func3 : ()() constant = {
        value1 = 6              // ERROR: value1 is `constant`
                                // (as function is constant)
    }
}
````


### `file` / `line` generate code directive

For generated source files, the file/line directives `[[file="<name>"]]` indicates to the compiler the current source was generated by some process using another file as input. The name indicates the path to that original file. The line directive `[[line=<n>, increment=<n>]]` indicates the original source's line number so the generated output's line number can track the original source. The `increment` argument indicates how much to increment the counted line number of the original source file per output line found in the file being compiled (whose default is `1`).

The `line` directive will reuse the last `file` directive (which must be present at least once within the same source file being compiled).

Other `source` directives found in a generated file will not presume the referenced source file was also generated. Thus the directives only applies to the file being parsed.

````zax
[[file="inputs.csv"]]
// example file generated by Acme Generator

[[line=21]]
apple : Integer
banana : Float
carrot : String

[[line=400, increment=0]]
donut : Float
egglessChocolateMousse : String

[[line=401, increment=0]]
fudge : Integer
gulabJamun : String
````


### `tab-stop` directive

The `tab-stop` directive `[[tab-stop=<n>]]` controls the source code tab stop for the tokens that follow. This control what alignment the tab ASCII character (`\t`) is assumed within the source code. Tab stops are reset to the default for each module imported. The default tab stop is `8` unless otherwise specified.

````zax
[[tab-stop=4]]

func : ()() = {
    // ...
}
````
